<haxe>
	<class path="Array" params="T" file="/usr/share/haxe/std/Array.hx" extern="1">
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
		The length of the Array
	</haxe_doc>
		</length>
		<concat public="1" set="method">
			<f a="a">
				<c path="Array"><c path="Array.T"/></c>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>
		Returns a new Array by appending [a] to [this].
	</haxe_doc>
		</concat>
		<join public="1" set="method">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns a representation of an array with [sep] for separating each element.
	</haxe_doc>
		</join>
		<pop public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>
		Removes the last element of the array and returns it.
	</haxe_doc>
		</pop>
		<push public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Adds the element [x] at the end of the array.
	</haxe_doc>
		</push>
		<reverse public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Reverse the order of elements of the Array.
	</haxe_doc>
		</reverse>
		<shift public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>
		Removes the first element and returns it.
	</haxe_doc>
		</shift>
		<slice public="1" set="method">
			<f a="pos:?end">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>
		Copies the range of the array starting at [pos] up to,
		but not including, [end]. Both [pos] and [end] can be
		negative to count from the end: -1 is the last item in
		the array.
	</haxe_doc>
		</slice>
		<sort public="1" set="method">
			<f a="f">
				<f a=":">
					<c path="Array.T"/>
					<c path="Array.T"/>
					<c path="Int"/>
				</f>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
		Sort the Array according to the comparison function [f].
		[f(x,y)] should return [0] if [x == y], [>0] if [x > y]
		and [<0] if [x < y].
	]]></haxe_doc>
		</sort>
		<splice public="1" set="method">
			<f a="pos:len">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>
		Removes [len] elements starting from [pos] an returns them.
	</haxe_doc>
		</splice>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns a displayable representation of the Array content.
	</haxe_doc>
		</toString>
		<unshift public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds the element [x] at the start of the array.
	</haxe_doc>
		</unshift>
		<insert public="1" set="method">
			<f a="pos:x">
				<c path="Int"/>
				<c path="Array.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Inserts the element [x] at the position [pos].
		All elements after [pos] are moved one index ahead.
	</haxe_doc>
		</insert>
		<remove public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Removes the first occurence of [x].
		Returns false if [x] was not present.
		Elements are compared by using standard equality.
	</haxe_doc>
		</remove>
		<copy public="1" set="method">
			<f a=""><c path="Array"><c path="Array.T"/></c></f>
			<haxe_doc>
		Returns a copy of the Array. The values are not
		copied, only the Array structure.
	</haxe_doc>
		</copy>
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><t path="Null"><c path="Array.T"/></t></t></f>
			<haxe_doc>
		Returns an iterator of the Array values.
	</haxe_doc>
		</iterator>
		<new public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Creates a new Array.
	</haxe_doc>
		</new>
		<haxe_doc>
	An Array is a storage for values. You can access it using indexes or
	with its API. On the server side, it's often better to use a [List] which
	is less memory and CPU consuming, unless you really need indexed access.
</haxe_doc>
	</class>
	<class path="Class" params="T" file="/usr/share/haxe/std/Class.hx" extern="1"><haxe_doc>
	An abstract type that represents a Class.
	See [Type] for the haXe Reflection API.
</haxe_doc></class>
	<class path="Enum" params="T" file="/usr/share/haxe/std/Enum.hx" extern="1"><haxe_doc>
	An abstract type that represents an Enum.
	See [Type] for the haXe Reflection API.
</haxe_doc></class>
	<class path="EnumValue" params="" file="/usr/share/haxe/std/EnumValue.hx" extern="1"><haxe_doc>
	An abstract type that represents any enum value.
	See [Type] for the haXe Reflection API.
</haxe_doc></class>
	<class path="IntIter" params="" file="/usr/share/haxe/std/IntIter.hx">
		<min><c path="Int"/></min>
		<max><c path="Int"/></max>
		<hasNext public="1" set="method" line="46">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>
		Returns true if the iterator has other items, false otherwise.
	</haxe_doc>
		</hasNext>
		<next public="1" set="method" line="53">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Moves to the next item of the iterator.
	</haxe_doc>
		</next>
		<new public="1" set="method" line="38">
			<f a="min:max">
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
		Iterate from [min] (inclusive) to [max] (exclusive).
		If [max <= min], the iterator will not act as a countdown.
	]]></haxe_doc>
		</new>
		<haxe_doc>
	Integer iterator. Used for interval implementation.
</haxe_doc>
	</class>
	<class path="List" params="T" file="/usr/share/haxe/std/List.hx">
		<h><c path="Array"><d/></c></h>
		<q><c path="Array"><d/></c></q>
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
		The number of elements in this list.
	</haxe_doc>
		</length>
		<add public="1" set="method" line="51">
			<f a="item">
				<c path="List.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Add an element at the end of the list.
	</haxe_doc>
		</add>
		<push public="1" set="method" line="64">
			<f a="item">
				<c path="List.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Push an element at the beginning of the list.
	</haxe_doc>
		</push>
		<first public="1" set="method" line="80">
			<f a=""><c path="List.T"/></f>
			<haxe_doc>
		Returns the first element of the list, or null
		if the list is empty.
	</haxe_doc>
		</first>
		<last public="1" set="method" line="88">
			<f a=""><c path="List.T"/></f>
			<haxe_doc>
		Returns the last element of the list, or null
		if the list is empty.
	</haxe_doc>
		</last>
		<pop public="1" set="method" line="98">
			<f a=""><c path="List.T"/></f>
			<haxe_doc>
		Removes the first element of the list and
		returns it or simply returns null if the
		list is empty.
	</haxe_doc>
		</pop>
		<isEmpty public="1" set="method" line="112">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>
		Tells if a list is empty.
	</haxe_doc>
		</isEmpty>
		<clear public="1" set="method" line="119">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Makes the list empty.
	</haxe_doc>
		</clear>
		<remove public="1" set="method" line="129">
			<f a="v">
				<c path="List.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Remove the first element that is [== v] from the list.
		Returns [true] if an element was removed, [false] otherwise.
	</haxe_doc>
		</remove>
		<iterator public="1" set="method" line="152">
			<f a=""><t path="Iterator"><c path="List.T"/></t></f>
			<haxe_doc>
		Returns an iterator on the elements of the list.
	</haxe_doc>
		</iterator>
		<toString public="1" set="method" line="173">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns a displayable representation of the String.
	</haxe_doc>
		</toString>
		<join public="1" set="method" line="193">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Join the element of the list by using the separator [sep].
	</haxe_doc>
		</join>
		<filter public="1" set="method" line="212">
			<f a="f">
				<f a="">
					<c path="List.T"/>
					<e path="Bool"/>
				</f>
				<c path="List"><c path="List.T"/></c>
			</f>
			<haxe_doc>
		Returns a list filtered with [f]. The returned list
		will contain all elements [x] for which [f(x) = true].
	</haxe_doc>
		</filter>
		<map public="1" params="X" set="method" line="228">
			<f a="f">
				<f a="">
					<c path="List.T"/>
					<c path="map.X"/>
				</f>
				<c path="List"><c path="map.X"/></c>
			</f>
			<haxe_doc>
		Returns a new list where all elements have been converted
		by the function [f].
	</haxe_doc>
		</map>
		<new public="1" set="method" line="44">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Creates a new empty list.
	</haxe_doc>
		</new>
		<haxe_doc>
	A linked-list of elements. The list is composed of two-elements arrays
	that are chained together. It's optimized so that adding or removing an
	element doesn't imply to copy the whole array content everytime.
</haxe_doc>
	</class>
	<class path="Math" params="" file="/usr/share/haxe/std/Math.hx" extern="1">
		<PI public="1" set="null" static="1"><c path="Float"/></PI>
		<NaN public="1" set="null" static="1"><c path="Float"/></NaN>
		<NEGATIVE_INFINITY public="1" set="null" static="1"><c path="Float"/></NEGATIVE_INFINITY>
		<POSITIVE_INFINITY public="1" set="null" static="1"><c path="Float"/></POSITIVE_INFINITY>
		<abs public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></abs>
		<min public="1" set="method" static="1"><f a="a:b">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></min>
		<max public="1" set="method" static="1"><f a="a:b">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></max>
		<sin public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></sin>
		<cos public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></cos>
		<atan2 public="1" set="method" static="1"><f a="y:x">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></atan2>
		<tan public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></tan>
		<exp public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></exp>
		<log public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></log>
		<sqrt public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></sqrt>
		<round public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Int"/>
</f></round>
		<floor public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Int"/>
</f></floor>
		<ceil public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Int"/>
</f></ceil>
		<atan public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></atan>
		<asin public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></asin>
		<acos public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></acos>
		<pow public="1" set="method" static="1"><f a="v:exp">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></pow>
		<random public="1" set="method" static="1"><f a=""><c path="Float"/></f></random>
		<isFinite public="1" set="method" static="1"><f a="f">
	<c path="Float"/>
	<e path="Bool"/>
</f></isFinite>
		<isNaN public="1" set="method" static="1"><f a="f">
	<c path="Float"/>
	<e path="Bool"/>
</f></isNaN>
		<haxe_doc>
	This class defines mathematical functions and constants.
</haxe_doc>
	</class>
	<class path="Object" params="" file="/usr/lib/haxe/lib/xirsys_stdjs/5,0,3/Object.hx" extern="1">
		<prototype public="1" static="1"><c path="Object"/></prototype>
		<length public="1" static="1"><c path="Int"/></length>
		<create public="1" set="method" static="1"><f a="o:?properties">
	<c path="Object"/>
	<d/>
	<c path="Object"/>
</f></create>
		<defineProperty public="1" set="method" static="1"><f a="o:p:attributes">
	<c path="Object"/>
	<c path="String"/>
	<d/>
	<c path="Object"/>
</f></defineProperty>
		<defineProperties public="1" set="method" static="1"><f a="o:?properties">
	<c path="Object"/>
	<d/>
	<c path="Object"/>
</f></defineProperties>
		<getPrototypeOf public="1" set="method" static="1"><f a="o">
	<c path="Object"/>
	<d/>
</f></getPrototypeOf>
		<keys public="1" set="method" static="1"><f a="o">
	<c path="Object"/>
	<c path="Array"><d/></c>
</f></keys>
		<seal public="1" set="method" static="1"><f a="o">
	<c path="Object"/>
	<c path="Object"/>
</f></seal>
		<freeze public="1" set="method" static="1"><f a="o">
	<c path="Object"/>
	<c path="Object"/>
</f></freeze>
		<preventExtensions public="1" set="method" static="1"><f a="o">
	<c path="Object"/>
	<c path="Object"/>
</f></preventExtensions>
		<isSealed public="1" set="method" static="1"><f a="o">
	<c path="Object"/>
	<e path="Bool"/>
</f></isSealed>
		<isFrozen public="1" set="method" static="1"><f a="o">
	<c path="Object"/>
	<e path="Bool"/>
</f></isFrozen>
		<isExtensible public="1" set="method" static="1"><f a="o">
	<c path="Object"/>
	<e path="Bool"/>
</f></isExtensible>
		<getOwnPropertyDescriptor public="1" set="method" static="1"><f a="o:p">
	<d/>
	<c path="String"/>
	<d/>
</f></getOwnPropertyDescriptor>
		<getOwnPropertyNames public="1" set="method" static="1"><f a="o">
	<d/>
	<c path="Array"><d/></c>
</f></getOwnPropertyNames>
		<constructor public="1"><d/></constructor>
		<hasOwnProperty public="1" set="method"><f a="prop">
	<c path="String"/>
	<e path="Bool"/>
</f></hasOwnProperty>
		<isPrototypeOf public="1" set="method"><f a="object">
	<c path="Object"/>
	<e path="Bool"/>
</f></isPrototypeOf>
		<propertyIsEnumerable public="1" set="method"><f a="prop">
	<c path="String"/>
	<e path="Bool"/>
</f></propertyIsEnumerable>
		<toLocaleString public="1" set="method"><f a=""><c path="String"/></f></toLocaleString>
		<toString public="1" set="method"><f a="?opt">
	<d/>
	<c path="String"/>
</f></toString>
		<valueOf public="1" set="method"><f a=""><d/></f></valueOf>
		<iterator public="1" set="method"><f a=""><t path="Iterator"><t path="Null"><d/></t></t></f></iterator>
		<instanceKeys public="1" set="method"><f a="?proto">
	<e path="Bool"/>
	<c path="Array"><c path="String"/></c>
</f></instanceKeys>
		<new public="1" set="method"><f a="?o">
	<d/>
	<e path="Void"/>
</f></new>
		<haxe_doc>****************************************************************************

Copyright (C) 2011 by XirSys

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

****************************************************************************</haxe_doc>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="Reflect" params="" file="/usr/share/haxe/std/js/_std/Reflect.hx">
		<hasField public="1" set="method" line="28" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if an object has a field set. This doesn't take into account the object prototype (class methods).
	</haxe_doc>
		</hasField>
		<field public="1" get="inline" set="null" line="32" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>
		Returns the field of an object, or null if [o] is not an object or doesn't have this field.
	</haxe_doc>
		</field>
		<setField public="1" get="inline" set="null" line="41" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set an object field value.
	</haxe_doc>
		</setField>
		<getProperty public="1" get="inline" set="null" line="45" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>
		Similar to field but also supports property (might be slower).
	</haxe_doc>
		</getProperty>
		<setProperty public="1" get="inline" set="null" line="50" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Similar to setField but also supports property (might be slower).
	</haxe_doc>
		</setProperty>
		<callMethod public="1" get="inline" set="null" line="55" static="1">
			<f a="o:func:args">
				<d/>
				<d/>
				<c path="Array"><d/></c>
				<d/>
			</f>
			<haxe_doc>
		Call a method with the given object and arguments.
	</haxe_doc>
		</callMethod>
		<fields public="1" set="method" line="59" static="1">
			<f a="o">
				<d/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Returns the list of fields of an object, excluding its prototype (class methods).
	</haxe_doc>
		</fields>
		<isFunction public="1" set="method" line="70" static="1">
			<f a="f">
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value is a function or not.
	</haxe_doc>
		</isFunction>
		<compare public="1" params="T" set="method" line="74" static="1">
			<f a="a:b">
				<c path="compare.T"/>
				<c path="compare.T"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Generic comparison function, does not work for methods, see [compareMethods]
	</haxe_doc>
		</compare>
		<compareMethods public="1" set="method" line="78" static="1">
			<f a="f1:f2">
				<d/>
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Compare two methods closures. Returns true if it's the same method of the same instance.
	</haxe_doc>
		</compareMethods>
		<isObject public="1" set="method" line="86" static="1">
			<f a="v">
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value is an object or not.

	</haxe_doc>
		</isObject>
		<deleteField public="1" set="method" line="93" static="1">
			<f a="o:f">
				<d/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Delete an object field.
	</haxe_doc>
		</deleteField>
		<copy public="1" params="T" set="method" line="99" static="1">
			<f a="o">
				<c path="copy.T"/>
				<c path="copy.T"/>
			</f>
			<haxe_doc>
		Make a copy of the fields of an object.
	</haxe_doc>
		</copy>
		<makeVarArgs public="1" set="method" line="106" static="1">
			<f a="f">
				<f a="">
					<c path="Array"><d/></c>
					<d/>
				</f>
				<d/>
			</f>
			<haxe_doc>
		Transform a function taking an array of arguments into a function that can
		be called with any number of arguments.
	</haxe_doc>
		</makeVarArgs>
		<haxe_doc>
	The Reflect API is a way to manipulate values dynamicly through an
	abstract interface in an untyped manner. Use with care.
</haxe_doc>
	</class>
	<class path="String" params="" file="/usr/share/haxe/std/String.hx" extern="1">
		<fromCharCode public="1" set="method" static="1"><f a="code">
	<c path="Int"/>
	<c path="String"/>
</f></fromCharCode>
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
		The number of characters in the String.
	</haxe_doc>
		</length>
		<toUpperCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns an String where all characters have been uppercased.
	</haxe_doc>
		</toUpperCase>
		<toLowerCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns an String where all characters have been lowercased.
	</haxe_doc>
		</toLowerCase>
		<charAt public="1" set="method">
			<f a="index">
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns the character at the given position.
		Returns the empty String if outside of String bounds.
	</haxe_doc>
		</charAt>
		<charCodeAt public="1" set="method">
			<f a="index">
				<c path="Int"/>
				<t path="Null"><c path="Int"/></t>
			</f>
			<haxe_doc>
		Returns the character code at the given position.
		Returns [null] if outside of String bounds.
	</haxe_doc>
		</charCodeAt>
		<indexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Returns the index of first occurence of [value]
		Returns [1-1] if [value] is not found.
		The optional [startIndex] parameter allows you to specify at which character to start searching.
		The position returned is still relative to the beginning of the string.
	</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Similar to [indexOf] but returns the latest index.
	</haxe_doc>
		</lastIndexOf>
		<split public="1" set="method">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Split the string using the specified delimiter.
	</haxe_doc>
		</split>
		<substr public="1" set="method">
			<f a="pos:?len">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns a part of the String, taking [len] characters starting from [pos].
		If [len] is not specified, it takes all the remaining characters.
	</haxe_doc>
		</substr>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns the String itself.
	</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="string">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Creates a copy from a given String.
	</haxe_doc>
		</new>
		<haxe_doc>
	The basic String class.
</haxe_doc>
	</class>
	<class path="Std" params="" file="/usr/share/haxe/std/js/_std/Std.hx">
		<is public="1" set="method" line="29" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value v is of the type t.
	</haxe_doc>
		</is>
		<string public="1" set="method" line="33" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Convert any value to a String
	</haxe_doc>
		</string>
		<int public="1" get="inline" set="null" line="37" static="1">
			<f a="x">
				<c path="Float"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Convert a Float to an Int, rounded down.
	</haxe_doc>
		</int>
		<parseInt public="1" set="method" line="41" static="1">
			<f a="x">
				<c path="String"/>
				<t path="Null"><c path="Int"/></t>
			</f>
			<haxe_doc>
		Convert a String to an Int, parsing different possible representations. Returns [null] if could not be parsed.
	</haxe_doc>
		</parseInt>
		<parseFloat public="1" set="method" line="51" static="1">
			<f a="x">
				<c path="String"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
		Convert a String to a Float, parsing different possible reprensations.
	</haxe_doc>
		</parseFloat>
		<random public="1" set="method" line="55" static="1">
			<f a="x">
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Return a random integer between 0 included and x excluded.
	</haxe_doc>
		</random>
		<haxe_doc>
	The Std class provides standard methods for manipulating basic types.
</haxe_doc>
	</class>
	<enum path="Void" params="" file="/usr/share/haxe/std/StdTypes.hx" module="StdTypes"><haxe_doc>
	The standard Void type. Only [null] values can be of the type [Void].
</haxe_doc></enum>
	<class path="Float" params="" file="/usr/share/haxe/std/StdTypes.hx" module="StdTypes" extern="1"><haxe_doc>
	The standard Float type, this is a double-precision IEEE 64bit float.
</haxe_doc></class>
	<class path="Int" params="" file="/usr/share/haxe/std/StdTypes.hx" module="StdTypes" extern="1">
		<extends path="Float"/>
		<haxe_doc>
	The standard Int type. Its precision depends on the platform.
</haxe_doc>
	</class>
	<typedef path="Null" params="T" file="/usr/share/haxe/std/StdTypes.hx" module="StdTypes">
		<c path="Null.T"/>
		<haxe_doc>
	[Null] can be useful in two cases. In order to document some methods
	that accepts or can return a [null] value, or for the Flash9 compiler and AS3
	generator to distinguish between base values that can be null and others that
	can't.
</haxe_doc>
	</typedef>
	<enum path="Bool" params="" file="/usr/share/haxe/std/StdTypes.hx" module="StdTypes">
		<true/>
		<false/>
		<haxe_doc>
	The standard Boolean type is represented as an enum with two choices.
</haxe_doc>
	</enum>
	<class path="Dynamic" params="T" file="/usr/share/haxe/std/StdTypes.hx" module="StdTypes" extern="1"><haxe_doc>
	Dynamic is an internal compiler type which has special behavior.
	See the haXe language reference for more informations.
</haxe_doc></class>
	<typedef path="Iterator" params="T" file="/usr/share/haxe/std/StdTypes.hx" module="StdTypes">
		<a>
			<next set="method"><f a=""><c path="Iterator.T"/></f></next>
			<hasNext set="method"><f a=""><e path="Bool"/></f></hasNext>
		</a>
		<haxe_doc>
	An Iterator is a structure that permits to list a given container
	values. It can be used by your own data structures. See the haXe
	documentation for more informations.
</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="/usr/share/haxe/std/StdTypes.hx" module="StdTypes">
		<a><iterator set="method"><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>
	An Iterable is a data structure which has an iterator() method.
	See [Lambda] for generic functions on iterable structures.
</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="/usr/share/haxe/std/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>
	ArrayAccess is used to indicate a class that can be accessed using brackets.
	The type parameter represent the type of the elements stored.
</haxe_doc></class>
	<class path="StringBuf" params="" file="/usr/share/haxe/std/StringBuf.hx">
		<add public="1" get="inline" set="null" line="46">
			<f a="x">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds the representation of any value to the string buffer.
	</haxe_doc>
		</add>
		<addSub public="1" get="inline" set="null" line="59">
			<f a="s:pos:?len">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds a part of a string to the string buffer.
	</haxe_doc>
		</addSub>
		<addChar public="1" get="inline" set="null" line="75">
			<f a="c">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds a character to the string buffer.
	</haxe_doc>
		</addChar>
		<toString public="1" get="inline" set="null" line="89">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns the content of the string buffer.
		The buffer is not emptied by this operation.
	</haxe_doc>
		</toString>
		<b><c path="Array"><d/></c></b>
		<new public="1" set="method" line="35">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Creates a new string buffer.
	</haxe_doc>
		</new>
		<haxe_doc>
	A String buffer is an efficient way to build a big string by
	appending small elements together.
</haxe_doc>
	</class>
	<enum path="ValueType" params="" file="/usr/share/haxe/std/js/_std/Type.hx" module="Type">
		<TUnknown/>
		<TObject/>
		<TNull/>
		<TInt/>
		<TFunction/>
		<TFloat/>
		<TEnum a="e"><c path="Enum"><d/></c></TEnum>
		<TClass a="c"><c path="Class"><d/></c></TClass>
		<TBool/>
	</enum>
	<class path="Type" params="" file="/usr/share/haxe/std/js/_std/Type.hx">
		<getClass public="1" params="T" set="method" line="40" static="1">
			<f a="o">
				<c path="getClass.T"/>
				<c path="Class"><c path="getClass.T"/></c>
			</f>
			<haxe_doc>
		Returns the class of a value or [null] if this value is not a Class instance.
	</haxe_doc>
		</getClass>
		<getEnum public="1" set="method" line="48" static="1">
			<f a="o">
				<c path="EnumValue"/>
				<c path="Enum"><d/></c>
			</f>
			<haxe_doc>
		Returns the enum of a value or [null] if this value is not an Enum instance.
	</haxe_doc>
		</getEnum>
		<getSuperClass public="1" set="method" line="54" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Class"><d/></c>
			</f>
			<haxe_doc>
		Returns the super-class of a class, or null if no super class.
	</haxe_doc>
		</getSuperClass>
		<getClassName public="1" set="method" line="59" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns the complete name of a class.
	</haxe_doc>
		</getClassName>
		<getEnumName public="1" set="method" line="64" static="1">
			<f a="e">
				<c path="Enum"><d/></c>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns the complete name of an enum.
	</haxe_doc>
		</getEnumName>
		<resolveClass public="1" set="method" line="69" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Class"><d/></c>
			</f>
			<haxe_doc>
		Evaluates a class from a name. The class must have been compiled
		to be accessible.
	</haxe_doc>
		</resolveClass>
		<resolveEnum public="1" set="method" line="77" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Enum"><d/></c>
			</f>
			<haxe_doc>
		Evaluates an enum from a name. The enum must have been compiled
		to be accessible.
	</haxe_doc>
		</resolveEnum>
		<createInstance public="1" params="T" set="method" line="85" static="1">
			<f a="cl:args">
				<c path="Class"><c path="createInstance.T"/></c>
				<c path="Array"><d/></c>
				<c path="createInstance.T"/>
			</f>
			<haxe_doc>
		Creates an instance of the given class with the list of constructor arguments.
	</haxe_doc>
		</createInstance>
		<createEmptyInstance public="1" params="T" set="method" line="111" static="1">
			<f a="cl">
				<c path="Class"><c path="createEmptyInstance.T"/></c>
				<c path="createEmptyInstance.T"/>
			</f>
			<haxe_doc>
		Similar to [Reflect.createInstance] excepts that the constructor is not called.
		This enables you to create an instance without any side-effect.
	</haxe_doc>
		</createEmptyInstance>
		<createEnum public="1" params="T" set="method" line="116" static="1">
			<f a="e:constr:?params">
				<c path="Enum"><c path="createEnum.T"/></c>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createEnum.T"/>
			</f>
			<haxe_doc>
		Create an instance of an enum by using a constructor name and parameters.
	</haxe_doc>
		</createEnum>
		<createEnumIndex public="1" params="T" set="method" line="128" static="1">
			<f a="e:index:?params">
				<c path="Enum"><c path="createEnumIndex.T"/></c>
				<c path="Int"/>
				<c path="Array"><d/></c>
				<c path="createEnumIndex.T"/>
			</f>
			<haxe_doc>
		Create an instance of an enum by using a constructor index and parameters.
	</haxe_doc>
		</createEnumIndex>
		<getInstanceFields public="1" set="method" line="134" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Returns the list of instance fields.
	</haxe_doc>
		</getInstanceFields>
		<getClassFields public="1" set="method" line="142" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Returns the list of a class static fields.
	</haxe_doc>
		</getClassFields>
		<getEnumConstructs public="1" set="method" line="152" static="1">
			<f a="e">
				<c path="Enum"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Returns all the available constructor names for an enum.
	</haxe_doc>
		</getEnumConstructs>
		<typeof public="1" set="method" line="157" static="1">
			<f a="v">
				<d/>
				<e path="ValueType"/>
			</f>
			<haxe_doc>
		Returns the runtime type of a value.
	</haxe_doc>
		</typeof>
		<enumEq public="1" params="T" set="method" line="187" static="1">
			<f a="a:b">
				<c path="enumEq.T"/>
				<c path="enumEq.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Recursively compare two enums constructors and parameters.
	</haxe_doc>
		</enumEq>
		<enumConstructor public="1" get="inline" set="null" line="205" static="1">
			<f a="e">
				<c path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns the constructor of an enum
	</haxe_doc>
		</enumConstructor>
		<enumParameters public="1" get="inline" set="null" line="209" static="1">
			<f a="e">
				<c path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>
		Returns the parameters of an enum
	</haxe_doc>
		</enumParameters>
		<enumIndex public="1" get="inline" set="null" line="213" static="1">
			<f a="e">
				<c path="EnumValue"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Returns the index of the constructor of an enum
	</haxe_doc>
		</enumIndex>
		<allEnums public="1" params="T" set="method" line="217" static="1">
			<f a="e">
				<c path="Enum"><c path="allEnums.T"/></c>
				<c path="Array"><c path="allEnums.T"/></c>
			</f>
			<haxe_doc>
		Returns the list of all enum values that don't take any parameter.
	</haxe_doc>
		</allEnums>
		<haxe_doc>
	The haXe Reflection API enables you to retreive informations about any value,
	Classes and Enums at runtime.
</haxe_doc>
	</class>
	<class path="demo.Test" params="" file="src/demo/Test.hx">
		<stateChangeCount line="8" static="1"><c path="Int"/></stateChangeCount>
		<main public="1" set="method" line="10" static="1"><f a=""><e path="Void"/></f></main>
	</class>
	<typedef path="haxe.PosInfos" params="" file="/usr/share/haxe/std/haxe/PosInfos.hx"><a>
	<methodName><c path="String"/></methodName>
	<lineNumber><c path="Int"/></lineNumber>
	<fileName><c path="String"/></fileName>
	<customParams><c path="Array"><d/></c></customParams>
	<className><c path="String"/></className>
</a></typedef>
	<enum path="haxe.StackItem" params="" file="/usr/share/haxe/std/haxe/Stack.hx" module="haxe.Stack">
		<Module a="m"><c path="String"/></Module>
		<Method a="classname:method">
			<c path="String"/>
			<c path="String"/>
		</Method>
		<Lambda a="v"><c path="Int"/></Lambda>
		<FilePos a="s:file:line">
			<t path="Null"><e path="haxe.StackItem"/></t>
			<c path="String"/>
			<c path="Int"/>
		</FilePos>
		<CFunction/>
		<haxe_doc>
	Elements return by [Stack] methods.
</haxe_doc>
	</enum>
	<class path="haxe.Stack" params="" file="/usr/share/haxe/std/haxe/Stack.hx">
		<callStack public="1" set="method" line="46" static="1">
			<f a=""><c path="Array"><e path="haxe.StackItem"/></c></f>
			<haxe_doc>
		Return the call stack elements.
	</haxe_doc>
		</callStack>
		<exceptionStack public="1" set="method" line="69" static="1">
			<f a=""><c path="Array"><e path="haxe.StackItem"/></c></f>
			<haxe_doc>
		Return the exception stack : this is the stack elements between
		the place the last exception was thrown and the place it was
		catched.
	</haxe_doc>
		</exceptionStack>
		<toString public="1" set="method" line="100" static="1">
			<f a="stack">
				<c path="Array"><e path="haxe.StackItem"/></c>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns a representation of the stack as a printable string.
	</haxe_doc>
		</toString>
		<itemToString set="method" line="109" static="1"><f a="b:s">
	<c path="StringBuf"/>
	<e path="haxe.StackItem"/>
	<e path="Void"/>
</f></itemToString>
		<makeStack set="method" line="135" static="1"><f a="s">
	<unknown/>
	<unknown/>
</f></makeStack>
		<haxe_doc>
	Get informations about the call stack.
</haxe_doc>
	</class>
	<class path="haxe.TypeTools" params="" file="/usr/lib/haxe/lib/hsl-pico-1/1,6/haxe/TypeTools.hx">
		<getClassNames public="1" set="method" line="40" static="1">
			<f a="value">
				<d/>
				<c path="List"><c path="String"/></c>
			</f>
			<haxe_doc>
	 * Returns a list of all the complete names of all the classes the passed value is an instance of. If the passed value itself
	 * is a class, this method will return a list containing its complete name and all its super classes. If you pass an instance
	 * of Sprite, for instance, this method will return a list containing "flash.display.Sprite",
	 * "flash.display.DisplayObjectContainer", "flash.display.InteractiveObject", "flash.display.DisplayObject" and
	 * "flash.events.EventDispatcher".
	 </haxe_doc>
		</getClassNames>
		<haxe_doc>
 * More advanced operations for reflection.
 </haxe_doc>
	</class>
	<class path="haxe.exception.Exception" params="" file="/usr/lib/haxe/lib/hsl-pico-1/1,6/haxe/exception/Exception.hx">
		<baseException public="1" get="getBaseException" set="null">
			<c path="haxe.exception.Exception"/>
			<haxe_doc>
	 * The initial exception that triggered the chain of exceptions resulting in this exception to be thrown. If this exception
	 * does not have any inner exceptions, this property is equal to this exception.
	 </haxe_doc>
		</baseException>
		<innerException public="1" set="null">
			<c path="haxe.exception.Exception"/>
			<haxe_doc>
	 * The exception that was thrown causing this exception to be thrown. If this exception does not have any inner exceptions,
	 * this property is null.
	 </haxe_doc>
		</innerException>
		<message public="1" set="null">
			<c path="String"/>
			<haxe_doc>
	 * The message associated with and describing this exception.
	 </haxe_doc>
		</message>
		<stackTrace public="1" set="null">
			<t path="Iterable"><e path="haxe.StackItem"/></t>
			<haxe_doc>
	 * The trace to the place where this exception was generated and thrown.
	 </haxe_doc>
		</stackTrace>
		<stackTraceArray>
			<c path="Array"><e path="haxe.StackItem"/></c>
			<haxe_doc>
	 * The same as the stackTrace property, only more accurately typed.
	 </haxe_doc>
		</stackTraceArray>
		<generateStackTrace get="inline" set="null" line="77">
			<f a="numberOfStackTraceShifts">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Generates the stacktrace. Is called in the constructor of this class. Calling this from somewhere else will result in a
	 * corrupted stacktrace.
	 </haxe_doc>
		</generateStackTrace>
		<getBaseException get="inline" set="null" line="90">
			<f a=""><c path="haxe.exception.Exception"/></f>
			<haxe_doc>
	 * Gets the base exception of this one.
	 </haxe_doc>
		</getBaseException>
		<toString set="method" line="97"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="60">
			<f a="?message:?innerException:?numberOfStackTraceShifts">
				<c path="String"/>
				<c path="haxe.exception.Exception"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Creates a new exception. Creating an exception automatically generates the corresponding stacktrace.
	 </haxe_doc>
		</new>
		<haxe_doc>
 * General base class for exceptions.
 </haxe_doc>
	</class>
	<class path="haxe.exception.ArgumentNullException" params="" file="/usr/lib/haxe/lib/hsl-pico-1/1,6/haxe/exception/ArgumentNullException.hx">
		<extends path="haxe.exception.Exception"/>
		<new public="1" set="method" line="36">
			<f a="?argumentName:?numberOfStackTraceShifts">
				<c path="String"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Creates a new argument null exception.
	 </haxe_doc>
		</new>
		<haxe_doc>
 * An exception that can be thown when an argument is null, while a non-null value is expected.
 </haxe_doc>
	</class>
	<class path="haxe.macro.Tools" params="" file="/usr/share/haxe/std/haxe/macro/Tools.hx" extern="1"><haxe_doc>
	Some macro utility methods that can be used on different platforms
</haxe_doc></class>
	<class path="hsl.haxe.Bond" params="" file="/usr/lib/haxe/lib/hsl-pico-1/1,6/hsl/haxe/Bond.hx">
		<halted public="1" set="null">
			<e path="Bool"/>
			<haxe_doc>
	 * Indicates whether the bond has been halted (true) or not (false). See the halt method for more information.
	 </haxe_doc>
		</halted>
		<willDestroyOnUse>
			<e path="Bool"/>
			<haxe_doc>
	 * Indicates whether the bond will be destroyed right after it is used (true) or not (false).
	 </haxe_doc>
		</willDestroyOnUse>
		<destroy public="1" set="method" line="58">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Destroys the bond. The signaler that created this bond will no longer notify listeners through it. Bond cannot be
	 * "undestroyed". To temporary suspend the bond from notifying the associated listener, use the halt method.
	 </haxe_doc>
		</destroy>
		<destroyOnUse public="1" set="method" line="65">
			<f a=""><c path="hsl.haxe.Bond"/></f>
			<haxe_doc>
	 * Destroys the bond right after it is used. Whether this bond has already been used at the moment this method is called does
	 * not matter: the bond will be destroyed on its first use after this method has been called. This method returns this bond
	 * itself.
	 </haxe_doc>
		</destroyOnUse>
		<halt public="1" get="inline" set="null" line="73">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Halts the bond. The bond will ignore any calls, and will not notify any listeners, until the resume method is called. If
	 * the bond was already halted, calling this method has no effect.
	 </haxe_doc>
		</halt>
		<resume public="1" get="inline" set="null" line="80">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Resumes the bond, after it has been halted by calling the halt method. If the bond was not halted, calling this method has
	 * no effect. See the halt method for more information.
	 </haxe_doc>
		</resume>
		<new public="1" set="method" line="48">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Creates a new bond.
	 </haxe_doc>
		</new>
		<haxe_doc>
 * A bond represents the connection between a signaler and a listener. Bonds are created when listeners add themselves to a
 * signaler.
 * 
 * Bonds are used internally, and can be ignored in common cases. However, sometimes it is useful for listeners to store the
 * bond in a variable. Doing so allows you to halt and resume the bond, and destroy it easily.
 </haxe_doc>
	</class>
	<class path="hsl.haxe.Signaler" params="Datatype" file="/usr/lib/haxe/lib/hsl-pico-1/1,6/hsl/haxe/Signaler.hx" interface="1">
		<isListenedTo public="1" get="getIsListenedTo" set="null">
			<e path="Bool"/>
			<haxe_doc><![CDATA[
	 * Indicates whether the signaler is listened to by at least one listener.
	 * 
	 * This property can be used for speed optimizations. If a signaler is not listened to, its subject does not have to
	 * calculate a value if that value will only be sent in a signal.
	 * 
	 * In this example the "Ball" class only calculates the distance if a listener is added to the signaler:
	 * <pre>
	 * package;
	 * import hsl.haxe.direct.DirectSignaler;
	 * import hsl.haxe.Signaler;
	 * class Ball {
	 * 	public var distanceUpdatedSignaler(default, null):DirectSignaler&lt;Float&gt;;
	 * 	public function new():Void {
	 * 		distanceUpdatedSignaler = new DirectSignaler(this);
	 * 	}
	 * 	public function move(x:Float, y:Float):Void {
	 * 		if (distanceUpdatedSignaler.isListenedTo) {
	 * 			var distance:Float = Math.sqrt(x * x + y * y);
	 * 			distanceUpdatedSignaler.dispatch(distance);
	 * 		}
	 * 	}
	 * }
	 * </pre>
	 ]]></haxe_doc>
		</isListenedTo>
		<subject public="1" set="null">
			<t path="hsl.haxe.Subject"/>
			<haxe_doc>
	 * The subject this signaler belongs to.
	 </haxe_doc>
		</subject>
		<addBubblingTarget public="1" set="method">
			<f a="value">
				<c path="hsl.haxe.Signaler"><c path="hsl.haxe.Signaler.Datatype"/></c>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
	 * Adds a bubbling target to the signaler. The signaler will bubble to this bubbling target in bubbling processes.
	 * 
	 * <ul><li>
	 * If you are familiar with events in ActionScript 3.0, or as3-signals by Robert Penner: those systems do not have an
	 * equivalent to this method, as they don't allow you to manually define where events/signals bubble to.
	 * </li></ul>
	 ]]></haxe_doc>
		</addBubblingTarget>
		<addNotificationTarget public="1" set="method">
			<f a="value">
				<c path="hsl.haxe.Signaler"><e path="Void"/></c>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
	 * Adds a notification target to the signaler. The signaler will notify to this notification target in bubbling processes,
	 * however, the data inside the signal will not be passed to this notification target.
	 * 
	 * <ul><li>
	 * If you are familiar with events in ActionScript 3.0, or as3-signals by Robert Penner: those systems do not have an
	 * equivalent to this method, as they don't allow you to manually define where events/signals bubble to.
	 * </li></ul>
	 ]]></haxe_doc>
		</addNotificationTarget>
		<bind public="1" set="method">
			<f a="listener">
				<f a="">
					<c path="hsl.haxe.Signaler.Datatype"/>
					<d/>
				</f>
				<c path="hsl.haxe.Bond"/>
			</f>
			<haxe_doc><![CDATA[
	 * Binds this signaler to a listener function that accepts an argument of the datatype of this signaler, and returns nothing.
	 * Returns the bond between the signaler. The bond can be removed by calling either the unbind method of the signaler, or the
	 * destroy method of the returned bond.
	 * 
	 * <ul><li>
	 * If you are familiar with jQuery: this method is similar to the "bind" method of that library.
	 * </li><li>
	 * If you are familiar with as3-signals by Robert Penner: this method is similar to the "add" method of that library.
	 * </li><li>
	 * If you are familiar with events in ActionScript 3.0: this method is similar to the "addEventListener" method of that
	 * system, though the bindAdvanced method of this library has more similarities to addEventListener.
	 * </li></ul>
	 ]]></haxe_doc>
		</bind>
		<bindAdvanced public="1" set="method">
			<f a="listener">
				<f a="">
					<c path="hsl.haxe.Signal"><c path="hsl.haxe.Signaler.Datatype"/></c>
					<d/>
				</f>
				<c path="hsl.haxe.Bond"/>
			</f>
			<haxe_doc><![CDATA[
	 * Binds this signaler to a listener function that accepts a signal, and returns nothing. Returns the bond between the
	 * signaler. The bond can be removed by calling either the unbindAdvanced method of the signaler, or the destroy method of
	 * the returned bond.
	 * 
	 * <ul><li>
	 * If you are familiar with jQuery: this method is similar to the "bind" method of that library.
	 * </li><li>
	 * If you are familiar with as3-signals by Robert Penner: this method is similar to the "add" method of that library, though
	 * the bind method of this library has more similarities to add.
	 * </li><li>
	 * If you are familiar with events in ActionScript 3.0: this method is similar to the "addEventListener" method of that
	 * system.
	 * </li></ul>
	 ]]></haxe_doc>
		</bindAdvanced>
		<bindVoid public="1" set="method">
			<f a="listener">
				<f a=""><d/></f>
				<c path="hsl.haxe.Bond"/>
			</f>
			<haxe_doc><![CDATA[
	 * Binds this signaler to a listener function that accepts nothing, and returns nothing. Returns the bond between the
	 * signaler. The bond can be removed by calling either the unbindVoid method of the signaler, or the destroy method of the
	 * returned bond.
	 * 
	 * <ul><li>
	 * If you are familiar with jQuery: this method is similar to the "bind" method of that library.
	 * </li><li>
	 * If you are familiar with as3-signals by Robert Penner: this method is similar to the "add" method of that library, though
	 * the bind method of this library has more similarities to add.
	 * </li><li>
	 * If you are familiar with events in ActionScript 3.0: this method is similar to the "addEventListener" method of that
	 * system, though the bindAdvanced method of this library has more similarities to addEventListener.
	 * </li></ul>
	 ]]></haxe_doc>
		</bindVoid>
		<dispatch public="1" set="method">
			<f a="?data:?origin:?positionInformation">
				<c path="hsl.haxe.Signaler.Datatype"/>
				<t path="hsl.haxe.Subject"/>
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Dispatches a signal, containing the passed data. All the listeners that are listening to this signaler will be notified.
	 * The signal will bubble to all of the bubbling targets that were added to this signaler. This method may only be called
	 * by the subject of the signaler.
	 </haxe_doc>
		</dispatch>
		<getIsListenedTo set="method"><f a=""><e path="Bool"/></f></getIsListenedTo>
		<removeBubblingTarget public="1" set="method">
			<f a="value">
				<c path="hsl.haxe.Signaler"><c path="hsl.haxe.Signaler.Datatype"/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Removes a bubbling target from the signaler. The signaler will stop bubbling to this bubbling target. If the signaler
	 * does not have the passed value as a bubbling target, calling this method has no effect.
	 </haxe_doc>
		</removeBubblingTarget>
		<removeNotificationTarget public="1" set="method">
			<f a="value">
				<c path="hsl.haxe.Signaler"><e path="Void"/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Removes a notification target from the signaler. The signaler will stop notifying this notification target. If the
	 * signaler does not have the passed value as a notification target, calling this method has no effect.
	 </haxe_doc>
		</removeNotificationTarget>
		<unbind public="1" set="method">
			<f a="listener">
				<f a="">
					<c path="hsl.haxe.Signaler.Datatype"/>
					<d/>
				</f>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Removed the bond between this signaler and a listener. If such bond does not exist, calling this method has no effect.
	 </haxe_doc>
		</unbind>
		<unbindAdvanced public="1" set="method">
			<f a="listener">
				<f a="">
					<c path="hsl.haxe.Signal"><c path="hsl.haxe.Signaler.Datatype"/></c>
					<d/>
				</f>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Removed the bond between this signaler and a listener. If such bond does not exist, calling this method has no effect.
	 </haxe_doc>
		</unbindAdvanced>
		<unbindVoid public="1" set="method">
			<f a="listener">
				<f a=""><d/></f>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Removed the bond between this signaler and a listener. If such bond does not exist, calling this method has no effect.
	 </haxe_doc>
		</unbindVoid>
		<haxe_doc><![CDATA[
 * A signalers is a tool, used by a subject to notify its environment (listeners). Subjects create their signalers, usually in
 * their constructors. Listeners add themselves to signalers by calling one of the binding methods.
 * 
 * <ul><li>
 * If you are familiar with as3-signals by Robert Penner: signalers are similar to "signals" in that library.
 * </li><li>
 * If you are familiar with events in ActionScript 3.0: signalers have some similarities to "event dispatchers" in that system.
 * There is one major difference, though: an event dispatcher can dispatch events of different event types; but in this library
 * each type of signal has its own signaler.
 * </li></ul>
 ]]></haxe_doc>
	</class>
	<class path="hsl.haxe.DirectSignaler" params="Datatype" file="/usr/lib/haxe/lib/hsl-pico-1/1,6/hsl/haxe/DirectSignaler.hx">
		<implements path="hsl.haxe.Signaler"><c path="hsl.haxe.DirectSignaler.Datatype"/></implements>
		<bubblingTargets><c path="List"><c path="hsl.haxe.Signaler"><c path="hsl.haxe.DirectSignaler.Datatype"/></c></c></bubblingTargets>
		<isListenedTo public="1" get="getIsListenedTo" set="null"><e path="Bool"/></isListenedTo>
		<notificationTargets><c path="List"><c path="hsl.haxe.Signaler"><e path="Void"/></c></c></notificationTargets>
		<rejectNullData><e path="Bool"/></rejectNullData>
		<sentinel><c path="hsl.haxe._DirectSignaler.SentinelBond"><c path="hsl.haxe.DirectSignaler.Datatype"/></c></sentinel>
		<subject public="1" set="null"><t path="hsl.haxe.Subject"/></subject>
		<subjectClassNames>
			<c path="List"><c path="String"/></c>
			<haxe_doc>
	 * The fully qualified class names of the subject.
	 </haxe_doc>
		</subjectClassNames>
		<addBubblingTarget public="1" set="method" line="64"><f a="value">
	<c path="hsl.haxe.Signaler"><c path="hsl.haxe.DirectSignaler.Datatype"/></c>
	<e path="Void"/>
</f></addBubblingTarget>
		<addNotificationTarget public="1" set="method" line="70"><f a="value">
	<c path="hsl.haxe.Signaler"><e path="Void"/></c>
	<e path="Void"/>
</f></addNotificationTarget>
		<bind public="1" set="method" line="76"><f a="listener">
	<f a="">
		<c path="hsl.haxe.DirectSignaler.Datatype"/>
		<d/>
	</f>
	<c path="hsl.haxe.Bond"/>
</f></bind>
		<bindAdvanced public="1" set="method" line="86"><f a="listener">
	<f a="">
		<c path="hsl.haxe.Signal"><c path="hsl.haxe.DirectSignaler.Datatype"/></c>
		<d/>
	</f>
	<c path="hsl.haxe.Bond"/>
</f></bindAdvanced>
		<bindVoid public="1" set="method" line="96"><f a="listener">
	<f a=""><d/></f>
	<c path="hsl.haxe.Bond"/>
</f></bindVoid>
		<bubble get="inline" set="null" line="106"><f a="data:origin">
	<c path="hsl.haxe.DirectSignaler.Datatype"/>
	<t path="hsl.haxe.Subject"/>
	<e path="Void"/>
</f></bubble>
		<dispatch public="1" set="method" line="121"><f a="?data:?origin:?positionInformation">
	<c path="hsl.haxe.DirectSignaler.Datatype"/>
	<t path="hsl.haxe.Subject"/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></dispatch>
		<getIsListenedTo set="method" line="162"><f a=""><e path="Bool"/></f></getIsListenedTo>
		<getOrigin get="inline" set="null" line="168">
			<f a="origin">
				<t path="hsl.haxe.Subject"/>
				<t path="hsl.haxe.Subject"/>
			</f>
			<haxe_doc>
	 * Returns the passed origin if it is not null. Returns the subject of this signaler if the passed origin is null.
	 </haxe_doc>
		</getOrigin>
		<verifyCaller set="method" line="188">
			<f a="positionInformation">
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Checks whether the class name inside the passed position information equals the class name of the subject of this
	 * signaler. Used in the dispatch method, as that method may only be called by the subject.
	 * 
	 * Two notes.
	 * One, by using this method you check whether the caller is of the same type as the subject, which does not necessarily mean
	 * it's the same instance. This is the expected behavior, as it is consistent with private members.
	 * Two, one could hack his or her way around this check. How to do this should be obvious. The check is not designed to be
	 * unhackable; rather it is designed to prevent developers from accidentally misapplying HSL. Nicolas Cannasse once said
	 * "everything should be made accessible, if you know what you're doing".
	 </haxe_doc>
		</verifyCaller>
		<removeBubblingTarget public="1" set="method" line="200"><f a="value">
	<c path="hsl.haxe.Signaler"><c path="hsl.haxe.DirectSignaler.Datatype"/></c>
	<e path="Void"/>
</f></removeBubblingTarget>
		<removeNotificationTarget public="1" set="method" line="205"><f a="value">
	<c path="hsl.haxe.Signaler"><e path="Void"/></c>
	<e path="Void"/>
</f></removeNotificationTarget>
		<unbind public="1" set="method" line="215"><f a="listener">
	<f a="">
		<c path="hsl.haxe.DirectSignaler.Datatype"/>
		<d/>
	</f>
	<e path="Void"/>
</f></unbind>
		<unbindAdvanced public="1" set="method" line="218"><f a="listener">
	<f a="">
		<c path="hsl.haxe.Signal"><c path="hsl.haxe.DirectSignaler.Datatype"/></c>
		<d/>
	</f>
	<e path="Void"/>
</f></unbindAdvanced>
		<unbindVoid public="1" set="method" line="221"><f a="listener">
	<f a=""><d/></f>
	<e path="Void"/>
</f></unbindVoid>
		<new public="1" set="method" line="54">
			<f a="subject:?rejectNullData">
				<t path="hsl.haxe.Subject"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Creates a new direct signaler.
	 * 
	 * The passed subject will be used as the subject of this signaler. Only the subject is allowed to call the dispatch method.
	 * Signals dispatched by this signaler will have the subject as current target, and in some cases as origin.
	 * 
	 * If the reject null data flag is set, the signaler will throw an exception if the subject attempts to dispatch a signal
	 * with null as data, or the the signaler is about to bubble a signal that contains null as data.
	 </haxe_doc>
		</new>
		<haxe_doc>
 * A signaler that dispatches signals directly.
 </haxe_doc>
	</class>
	<class path="hsl.haxe._DirectSignaler.LinkedBond" params="Datatype" file="/usr/lib/haxe/lib/hsl-pico-1/1,6/hsl/haxe/DirectSignaler.hx" private="1" module="hsl.haxe.DirectSignaler">
		<extends path="hsl.haxe.Bond"/>
		<destroyed><e path="Bool"/></destroyed>
		<next><c path="hsl.haxe._DirectSignaler.LinkedBond"><c path="hsl.haxe._DirectSignaler.LinkedBond.Datatype"/></c></next>
		<previous><c path="hsl.haxe._DirectSignaler.LinkedBond"><c path="hsl.haxe._DirectSignaler.LinkedBond.Datatype"/></c></previous>
		<callListener public="1" set="method" line="244">
			<f a="data:currentTarget:origin:propagationStatus">
				<c path="hsl.haxe._DirectSignaler.LinkedBond.Datatype"/>
				<t path="hsl.haxe.Subject"/>
				<t path="hsl.haxe.Subject"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Calls the listener stored inside. Classes that extend this one should override this method.
	 </haxe_doc>
		</callListener>
		<determineEquals set="method" line="251">
			<f a="value">
				<c path="hsl.haxe._DirectSignaler.LinkedBond"><c path="hsl.haxe._DirectSignaler.LinkedBond.Datatype"/></c>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	 * Determines whether the passed bond equals this one. Returns true if they are equal; false otherwise. Classes that extend
	 * this one should override this method.
	 </haxe_doc>
		</determineEquals>
		<destroy public="1" set="method" line="254" override="1"><f a=""><e path="Void"/></f></destroy>
		<unlink get="inline" set="null" line="261"><f a=""><e path="Void"/></f></unlink>
		<new public="1" set="method" line="234"><f a=""><e path="Void"/></f></new>
		<haxe_doc>
 * A doubly linked bond. The bond has a reference to the next and the previous bond in the list.
 </haxe_doc>
	</class>
	<class path="hsl.haxe._DirectSignaler.SentinelBond" params="Datatype" file="/usr/lib/haxe/lib/hsl-pico-1/1,6/hsl/haxe/DirectSignaler.hx" private="1" module="hsl.haxe.DirectSignaler">
		<extends path="hsl.haxe._DirectSignaler.LinkedBond"><c path="hsl.haxe._DirectSignaler.SentinelBond.Datatype"/></extends>
		<isConnected public="1" get="getIsConnected" set="null">
			<e path="Bool"/>
			<haxe_doc>
	 * Indicates whether this sentinel is connected to other bonds (true), or not (false).
	 </haxe_doc>
		</isConnected>
		<add public="1" get="inline" set="null" line="291">
			<f a="value">
				<c path="hsl.haxe._DirectSignaler.LinkedBond"><c path="hsl.haxe._DirectSignaler.SentinelBond.Datatype"/></c>
				<c path="hsl.haxe._DirectSignaler.LinkedBond"><c path="hsl.haxe._DirectSignaler.SentinelBond.Datatype"/></c>
			</f>
			<haxe_doc>
	 * Inserts a bond between the sentinel and the previous bond. Effectively, the newely added bond ends up being the last one
	 * in the list.
	 </haxe_doc>
		</add>
		<callListener public="1" set="method" line="296" override="1"><f a="data:currentTarget:origin:propagationStatus">
	<c path="hsl.haxe._DirectSignaler.SentinelBond.Datatype"/>
	<t path="hsl.haxe.Subject"/>
	<t path="hsl.haxe.Subject"/>
	<c path="Int"/>
	<c path="Int"/>
</f></callListener>
		<getIsConnected get="inline" set="null" line="307">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>
	 * Determines whether this sentinel is connected to other bonds (true), or not (false).
	 </haxe_doc>
		</getIsConnected>
		<remove public="1" get="inline" set="null" line="317">
			<f a="value">
				<c path="hsl.haxe._DirectSignaler.LinkedBond"><c path="hsl.haxe._DirectSignaler.SentinelBond.Datatype"/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Removes a bond connected to the sentinel.
	 * 
	 * The sentinel will look for the first bond equal to the passed value connected to it, and destroy it.
	 </haxe_doc>
		</remove>
		<new public="1" set="method" line="283">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Creates a new sentinel bond.
	 </haxe_doc>
		</new>
		<haxe_doc>
 * A sentinel "bond". The sentinel is not a real bond, as it does not bind the signaler to a listener. Rather it is the value
 * before the first bond and after the last bond of this signaler. It contains logic that helps the signaler working with the
 * linked list structure.
 </haxe_doc>
	</class>
	<class path="hsl.haxe._DirectSignaler.RegularBond" params="Datatype" file="/usr/lib/haxe/lib/hsl-pico-1/1,6/hsl/haxe/DirectSignaler.hx" private="1" module="hsl.haxe.DirectSignaler">
		<extends path="hsl.haxe._DirectSignaler.LinkedBond"><c path="hsl.haxe._DirectSignaler.RegularBond.Datatype"/></extends>
		<listener><f a="">
	<c path="hsl.haxe._DirectSignaler.RegularBond.Datatype"/>
	<e path="Void"/>
</f></listener>
		<callListener public="1" set="method" line="337" override="1"><f a="data:currentTarget:origin:propagationStatus">
	<c path="hsl.haxe._DirectSignaler.RegularBond.Datatype"/>
	<t path="hsl.haxe.Subject"/>
	<t path="hsl.haxe.Subject"/>
	<c path="Int"/>
	<c path="Int"/>
</f></callListener>
		<determineEquals set="method" line="346" override="1"><f a="value">
	<c path="hsl.haxe._DirectSignaler.LinkedBond"><c path="hsl.haxe._DirectSignaler.RegularBond.Datatype"/></c>
	<e path="Bool"/>
</f></determineEquals>
		<new public="1" set="method" line="333"><f a="listener">
	<f a="">
		<c path="hsl.haxe._DirectSignaler.RegularBond.Datatype"/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></new>
		<haxe_doc>
 * A regular bond is a bond that is created in result of a call to the bind method.
 </haxe_doc>
	</class>
	<class path="hsl.haxe._DirectSignaler.NiladicBond" params="Datatype" file="/usr/lib/haxe/lib/hsl-pico-1/1,6/hsl/haxe/DirectSignaler.hx" private="1" module="hsl.haxe.DirectSignaler">
		<extends path="hsl.haxe._DirectSignaler.LinkedBond"><c path="hsl.haxe._DirectSignaler.NiladicBond.Datatype"/></extends>
		<listener><f a=""><e path="Void"/></f></listener>
		<callListener public="1" set="method" line="369" override="1"><f a="data:currentTarget:origin:propagationStatus">
	<c path="hsl.haxe._DirectSignaler.NiladicBond.Datatype"/>
	<t path="hsl.haxe.Subject"/>
	<t path="hsl.haxe.Subject"/>
	<c path="Int"/>
	<c path="Int"/>
</f></callListener>
		<determineEquals set="method" line="378" override="1"><f a="value">
	<c path="hsl.haxe._DirectSignaler.LinkedBond"><c path="hsl.haxe._DirectSignaler.NiladicBond.Datatype"/></c>
	<e path="Bool"/>
</f></determineEquals>
		<new public="1" set="method" line="365">
			<f a="listener">
				<f a=""><e path="Void"/></f>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Creates a new niladic bond.
	 </haxe_doc>
		</new>
		<haxe_doc>
 * A niladic bond is a bond that is created in result of a call to the bindVoid method.
 </haxe_doc>
	</class>
	<class path="hsl.haxe._DirectSignaler.AdvancedBond" params="Datatype" file="/usr/lib/haxe/lib/hsl-pico-1/1,6/hsl/haxe/DirectSignaler.hx" private="1" module="hsl.haxe.DirectSignaler">
		<extends path="hsl.haxe._DirectSignaler.LinkedBond"><c path="hsl.haxe._DirectSignaler.AdvancedBond.Datatype"/></extends>
		<listener><f a="">
	<c path="hsl.haxe.Signal"><c path="hsl.haxe._DirectSignaler.AdvancedBond.Datatype"/></c>
	<e path="Void"/>
</f></listener>
		<callListener public="1" set="method" line="401" override="1"><f a="data:currentTarget:origin:propagationStatus">
	<c path="hsl.haxe._DirectSignaler.AdvancedBond.Datatype"/>
	<t path="hsl.haxe.Subject"/>
	<t path="hsl.haxe.Subject"/>
	<c path="Int"/>
	<c path="Int"/>
</f></callListener>
		<determineEquals set="method" line="416" override="1"><f a="value">
	<c path="hsl.haxe._DirectSignaler.LinkedBond"><c path="hsl.haxe._DirectSignaler.AdvancedBond.Datatype"/></c>
	<e path="Bool"/>
</f></determineEquals>
		<new public="1" set="method" line="397">
			<f a="listener">
				<f a="">
					<c path="hsl.haxe.Signal"><c path="hsl.haxe._DirectSignaler.AdvancedBond.Datatype"/></c>
					<e path="Void"/>
				</f>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Creates a new advanced bond.
	 </haxe_doc>
		</new>
		<haxe_doc>
 * An advanced bond is a bond that is created in result of a call to the bindAdvanced method.
 </haxe_doc>
	</class>
	<class path="hsl.haxe._DirectSignaler.PropagationStatus" params="" file="/usr/lib/haxe/lib/hsl-pico-1/1,6/hsl/haxe/DirectSignaler.hx" private="1" module="hsl.haxe.DirectSignaler">
		<IMMEDIATELY_STOPPED public="1" get="inline" set="null" line="428" static="1"><c path="Int"/></IMMEDIATELY_STOPPED>
		<STOPPED public="1" get="inline" set="null" line="429" static="1"><c path="Int"/></STOPPED>
		<UNDISTURBED public="1" get="inline" set="null" line="430" static="1"><c path="Int"/></UNDISTURBED>
	</class>
	<class path="hsl.haxe.Signal" params="Datatype" file="/usr/lib/haxe/lib/hsl-pico-1/1,6/hsl/haxe/Signal.hx">
		<currentBond public="1" set="null">
			<c path="hsl.haxe.Bond"/>
			<haxe_doc>
	 * The bond that is currently processing the signal.
	 </haxe_doc>
		</currentBond>
		<currentTarget public="1" set="null">
			<t path="hsl.haxe.Subject"/>
			<haxe_doc><![CDATA[
	 * The subject that is currently dispatching this signal. This subject might be the origin for this signal, but could also be
	 * dispatching this signal in a bubbling process. For instance, if a user clicks on a button that is inside a menu, and
	 * signals bubble from that button to that menu, the currentTarget will be the button at some point and the menu at another.
	 * The origin will constantly be the button. In other words, the currentTarget is the subject the listener added itself to.
	 * 
	 * <ul><li>
	 * If you are familiar with events in ActionScript 3.0, jQuery, or any other system that was based on DOM level 3 events:
	 * this property is similar to the currentTarget property of the event objects in those systems.
	 * </li></ul>
	 * 
	 * In this example, the currentTarget property is used to determine which button was clicked. Note that this example is
	 * AVM2-specific, and requires the complete version of HSL (not just HSL-pico).
	 * <pre>
	 * package;
	 * import flash.display.Sprite;
	 * import flash.events.MouseEvent;
	 * import flash.Lib;
	 * import hsl.avm2.translating.AVM2Signaler;
	 * import hsl.haxe.direct.DirectSignaler;
	 * import hsl.haxe.Signal;
	 * import hsl.haxe.Signaler;
	 * class Main {
	 * 	public static function addButton(x:Float, color:Int):Void {
	 * 		var button:Button = new Button(color);
	 * 		button.x = x;
	 * 		button.clickedSignaler.bindAdvanced(handleButtonClicked);
	 * 		Lib.current.addChild(button);
	 * 	}
	 * 	public static function handleButtonClicked(signal:Signal&lt;Void&gt):Void {
	 * 		var button:Button = cast(signal.currentTarget, Button);
	 * 		trace("A button was clicked with this color: #" + StringTools.hex(button.color));
	 * 		removeButton(button);
	 * 	}
	 * 	private static function removeButton(button:Button):Void {
	 * 		button.clickedSignaler.unbindAdvanced(handleButtonClicked);
	 * 		Lib.current.removeChild(button);
	 * 	}
	 * 	public static function main():Void {
	 * 		addButton(0, 0x61C8E1);
	 * 		addButton(150, 0x61C8E1);
	 * 		addButton(300, 0xF68A1E);
	 * 		addButton(450, 0x61C8E1);
	 * 	}
	 * }
	 * class Button extends Sprite {
	 * 	public var clickedSignaler(default, null):Signaler&lt;Void&gt;;
	 * 	public var color:Int;
	 * 	public function new(color:Int):Void {
	 * 		super();
	 * 		clickedSignaler = new AVM2Signaler(this, this, MouseEvent.CLICK);
	 * 		this.color = color;
	 * 		buttonMode = true;
	 * 		draw();
	 * 	}
	 * 	private inline function draw():Void {
	 * 		graphics.beginFill(color);
	 * 		graphics.drawRoundRect(0, 0, 125, 77, 16);
	 * 		graphics.endFill();
	 * 	}
	 * }
	 * </pre>
	 * Note that this example is somewhat complex, and might be hard to understand if you are not familiar with the basics of
	 * this library.
	 ]]></haxe_doc>
		</currentTarget>
		<data public="1" set="null">
			<c path="hsl.haxe.Signal.Datatype"/>
			<haxe_doc>
	 * The data element in this signal.
	 </haxe_doc>
		</data>
		<data1 public="1" get="getData" set="null">
			<c path="hsl.haxe.Signal.Datatype"/>
			<haxe_doc>
	 * Deprecated. Equal to the data property.
	 </haxe_doc>
		</data1>
		<immediatePropagationStopped public="1" set="null">
			<e path="Bool"/>
			<haxe_doc>
	 * Indicates whether stopImmediatePropagation method was called on this signal (true) or not (false).
	 </haxe_doc>
		</immediatePropagationStopped>
		<origin public="1" set="null">
			<t path="hsl.haxe.Subject"/>
			<haxe_doc><![CDATA[
	 * The subject that initially dispatched this signal. For instance, if a user clicks on a button that is inside a menu, and
	 * signals bubble from that button to that menu, the currentTarget will be the button at some point and the menu at another.
	 * The origin will constantly be the button. In other words, the origin is the subject that called the dispatch method.
	 * 
	 * <ul><li>
	 * If you are familiar with events in ActionScript 3.0, jQuery, or any other system that was based on DOM level 3 events:
	 * this property is similar to the target property of the event objects in those systems.
	 * </li></ul>
	 ]]></haxe_doc>
		</origin>
		<propagationStopped public="1" set="null">
			<e path="Bool"/>
			<haxe_doc>
	 * Indicates whether stopPropagation method was called on this signal (true) or not (false). stopPropagation calls on other
	 * signals, even in the same dispatch process, don't influence this property.
	 </haxe_doc>
		</propagationStopped>
		<getData get="inline" set="null" line="148"><f a=""><c path="hsl.haxe.Signal.Datatype"/></f></getData>
		<stopImmediatePropagation public="1" get="inline" set="null" line="213">
			<f a=""><e path="Void"/></f>
			<haxe_doc><![CDATA[
	 * Stops all propagation of the signal. The subject currently dispatching this signal (as found in the target property of
	 * this the signal) stops doing so right away. Any other listeners that are listening are not notified.
	 * 
	 * <ul><li>
	 * If you are familiar with events in ActionScript 3.0, jQuery, or any other system that was based on DOM level 3 events:
	 * this method is similar to the stopImmediatePropagation method of the event objects in those systems.
	 * </li></ul>
	 * 
	 * In this example, the stopImmediatePropagation method is used to mute the sound that was produces by the "Muter" class:
	 * <pre>
	 * package;
	 * import hsl.haxe.direct.DirectSignaler;
	 * import hsl.haxe.Bond;
	 * import hsl.haxe.Signal;
	 * import hsl.haxe.Signaler;
	 * class Main {
	 * 	public static function traceCheer():Void {
	 * 		trace("Yay!");
	 * 	}
	 * 	public static function main():Void {
	 * 		var speaker:Speaker = new Speaker();
	 * 		var muter:Muter = new Muter(speaker);
	 * 		speaker.soundProducedSignaler.bindVoid(traceCheer);
	 * 		// This has no effect: the muter stops the signal propagation.
	 * 		speaker.produceSound();
	 * 		muter.disable();
	 * 		// This traces the cheer: the muter is disabled.
	 * 		speaker.produceSound();
	 * 		muter.enable();
	 * 		// This has no effect: the muter is re-enabled.
	 * 		speaker.produceSound();
	 * 	}
	 * }
	 * class Speaker {
	 * 	public var soundProducedSignaler(default, null):Signaler&lt;Void&gt;;
	 * 	public function new():Void {
	 * 		soundProducedSignaler = new DirectSignaler(this);
	 * 	}
	 * 	public inline function produceSound():Void {
	 * 		soundProducedSignaler.dispatch();
	 * 	}
	 * }
	 * class Muter {
	 * 	private var muteBond:Bond;
	 * 	public function new(speaker:Speaker):Void {
	 * 		muteBond = speaker.soundProducedSignaler.bindAdvanced(mute);
	 * 	}
	 * 	public inline function disable():Void {
	 * 		muteBond.halt();
	 * 	}
	 * 	public inline function enable():Void {
	 * 		muteBond.resume();
	 * 	}
	 * 	private function mute(signal:Signal&lt;Void&gt;):Void {
	 * 		signal.stopImmediatePropagation();
	 * 	}
	 * }
	 * </pre>
	 * Note that this example is somewhat complex, and might be hard to understand if you are not familiar with the basics of
	 * this library.
	 ]]></haxe_doc>
		</stopImmediatePropagation>
		<stopPropagation public="1" get="inline" set="null" line="226">
			<f a=""><e path="Void"/></f>
			<haxe_doc><![CDATA[
	 * Stops the bubbling of the signal. The subject currently dispatching this signal (as found in the target property of this
	 * the signal) will not bubble it to its bubbling targets. Calling this method does not prevent other listeners of the same
	 * signaler from being called: see stopImmediatePropagation for that functionality.
	 * 
	 * <ul><li>
	 * If you are familiar with events in ActionScript 3.0, jQuery, or any other system that was based on DOM level 3 events:
	 * this method is similar to the stopPropagation method of the event objects in those systems.
	 * </li></ul>
	 ]]></haxe_doc>
		</stopPropagation>
		<new public="1" set="method" line="136">
			<f a="data:currentBond:currentTarget:origin">
				<c path="hsl.haxe.Signal.Datatype"/>
				<c path="hsl.haxe.Bond"/>
				<t path="hsl.haxe.Subject"/>
				<t path="hsl.haxe.Subject"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Creates a new signal. Signals are usually created by signalers, so this constructor will probably not be called outside of
	 * the library itself.
	 </haxe_doc>
		</new>
		<haxe_doc>
 * A signal is dispatched by a subject, through a signaler. However, only listeners that were added using the bindAdvanced
 * method can access the actual Signal instances.
 </haxe_doc>
	</class>
	<typedef path="hsl.haxe.Subject" params="" file="/usr/lib/haxe/lib/hsl-pico-1/1,6/hsl/haxe/Subject.hx">
		<a/>
		<haxe_doc><![CDATA[
 * A subject is an object that might have internal state changes, which could be of interest to their environment. It notifies
 * its environment of such state changes by dispatching signals, rather than directly calling one of the methods of the
 * listeners. Subjects dispatch signals through signalers. Listeners can add themselves to those signalers.
 * 
 * Use of this technique results in low coupling between the subjects and their listeners. See
 * <a href="http://en.wikipedia.org/wiki/Coupling_(computer_science)">Coupling</a> on Wikipedia for more information.
 * 
 * Any class can act as a subject. Subjects can have any number of signalers.
 * 
 * In this example, the "buddy" variable (an instance of the "Dog" class) is a subject. The main class is a listener.
 * <pre>
 * package;
 * import hsl.haxe.direct.DirectSignaler;
 * import hsl.haxe.Signaler;
 * class Main {
 * 	public static function traceSound(sound:String):Void {
 * 		trace(sound);
 * 	}
 * 	public static function main():Void {
 * 		var buddy:Dog = new Dog();
 * 		buddy.barkedSignaler.bind(traceSound);
 * 		buddy.bark();
 * 	}
 * }
 * class Dog {
 * 	public var barkedSignaler(default, null):Signaler&lt;String&gt;;
 * 	public function new():Void {
 * 		barkedSignaler = new DirectSignaler(this);
 * 	}
 * 	public inline function bark():Void {
 * 		barkedSignaler.dispatch("Woof");
 * 	}
 * }
 * </pre>
 ]]></haxe_doc>
	</typedef>
	<class path="js.Boot" params="" file="/usr/share/haxe/std/js/Boot.hx">
		<__unhtml set="method" line="29" static="1"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></__unhtml>
		<__trace set="method" line="33" static="1"><f a="v:i">
	<a>
		<toString set="null"><f a=""><c path="String"/></f></toString>
		<length set="null"><c path="Int"/></length>
		<hasOwnProperty set="null"><f a="">
	<c path="String"/>
	<e path="Bool"/>
</f></hasOwnProperty>
		<__name__ set="null"><unknown/></__name__>
		<__enum__ set="null"><unknown/></__enum__>
		<__ename__ set="null"><unknown/></__ename__>
	</a>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></__trace>
		<__clear_trace set="method" line="50" static="1"><f a=""><e path="Void"/></f></__clear_trace>
		<__string_rec set="method" line="62" static="1"><f a="o:s">
	<a>
		<toString set="null"><f a=""><c path="String"/></f></toString>
		<length set="null"><c path="Int"/></length>
		<hasOwnProperty set="null"><f a="">
	<c path="String"/>
	<e path="Bool"/>
</f></hasOwnProperty>
		<__name__ set="null"><unknown/></__name__>
		<__enum__ set="null"><unknown/></__enum__>
		<__ename__ set="null"><unknown/></__ename__>
	</a>
	<a><length set="null"><c path="Int"/></length></a>
	<c path="String"/>
</f></__string_rec>
		<__interfLoop set="method" line="134" static="1"><f a="cc:cl">
	<d/>
	<d/>
	<e path="Bool"/>
</f></__interfLoop>
		<__instanceof set="method" line="149" static="1"><f a="o:cl">
	<d/>
	<t path="#Array"/>
	<e path="Bool"/>
</f></__instanceof>
		<__init set="method" line="182" static="1"><f a=""><e path="Void"/></f></__init>
	</class>
	<class path="js.HtmlCollection" params="T" file="/usr/share/haxe/std/js/Dom.hx" module="js.Dom" extern="1">
		<length public="1" set="null"><c path="Int"/></length>
		<haxe_dynamic><c path="js.HtmlCollection.T"/></haxe_dynamic>
	</class>
	<typedef path="js.MetaDom" params="T" file="/usr/share/haxe/std/js/Dom.hx" module="js.Dom"><a>
	<setAttribute set="method"><f a="attr:val">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></setAttribute>
	<replaceChild set="method"><f a="child:oldChild">
	<c path="js.MetaDom.T"/>
	<c path="js.MetaDom.T"/>
	<e path="Void"/>
</f></replaceChild>
	<removeChild set="method"><f a="child">
	<c path="js.MetaDom.T"/>
	<c path="js.MetaDom.T"/>
</f></removeChild>
	<previousSibling><c path="js.MetaDom.T"/></previousSibling>
	<parentNode><c path="js.MetaDom.T"/></parentNode>
	<nodeValue><c path="String"/></nodeValue>
	<nodeType><c path="Int"/></nodeType>
	<nodeName><c path="String"/></nodeName>
	<nextSibling><c path="js.MetaDom.T"/></nextSibling>
	<lastChild><c path="js.MetaDom.T"/></lastChild>
	<insertBefore set="method"><f a="newChild:refChild">
	<c path="js.MetaDom.T"/>
	<c path="js.MetaDom.T"/>
	<e path="Void"/>
</f></insertBefore>
	<hasChildNodes set="method"><f a=""><e path="Bool"/></f></hasChildNodes>
	<getAttribute set="method"><f a="attr">
	<c path="String"/>
	<c path="String"/>
</f></getAttribute>
	<firstChild><c path="js.MetaDom.T"/></firstChild>
	<cloneNode set="method"><f a="deep">
	<e path="Bool"/>
	<c path="js.MetaDom.T"/>
</f></cloneNode>
	<childNodes><c path="js.HtmlCollection"><c path="js.MetaDom.T"/></c></childNodes>
	<appendChild set="method"><f a="child">
	<c path="js.MetaDom.T"/>
	<e path="Void"/>
</f></appendChild>
</a></typedef>
	<typedef path="js.Dom" params="" file="/usr/share/haxe/std/js/Dom.hx"><t path="js.MetaDom"><t path="js.Dom"/></t></typedef>
	<typedef path="js.HtmlDom" params="" file="/usr/share/haxe/std/js/Dom.hx" module="js.Dom"><a>
	<title><c path="String"/></title>
	<style><t path="js.Style"/></style>
	<setAttribute set="method"><f a="attr:val">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></setAttribute>
	<scrollWidth set="null"><c path="Int"/></scrollWidth>
	<scrollTop><c path="Int"/></scrollTop>
	<scrollLeft><c path="Int"/></scrollLeft>
	<scrollHeight set="null"><c path="Int"/></scrollHeight>
	<replaceChild set="method"><f a="child:oldChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></replaceChild>
	<removeChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
</f></removeChild>
	<previousSibling><t path="js.HtmlDom"/></previousSibling>
	<parentNode><t path="js.HtmlDom"/></parentNode>
	<onscroll><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onscroll>
	<onresize><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onresize>
	<onmouseup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseup>
	<onmouseover><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseover>
	<onmouseout><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseout>
	<onmousemove><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousemove>
	<onmousedown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousedown>
	<onkeyup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeyup>
	<onkeypress><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeypress>
	<onkeydown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeydown>
	<onfocus><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onfocus>
	<ondblclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></ondblclick>
	<onclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onclick>
	<onblur><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onblur>
	<offsetWidth><c path="Int"/></offsetWidth>
	<offsetTop><c path="Int"/></offsetTop>
	<offsetParent><t path="js.HtmlDom"/></offsetParent>
	<offsetLeft><c path="Int"/></offsetLeft>
	<offsetHeight><c path="Int"/></offsetHeight>
	<nodeValue><c path="String"/></nodeValue>
	<nodeType><c path="Int"/></nodeType>
	<nodeName><c path="String"/></nodeName>
	<nextSibling><t path="js.HtmlDom"/></nextSibling>
	<lastChild><t path="js.HtmlDom"/></lastChild>
	<lang><c path="String"/></lang>
	<insertBefore set="method"><f a="newChild:refChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></insertBefore>
	<innerHTML><c path="String"/></innerHTML>
	<id><c path="String"/></id>
	<hasChildNodes set="method"><f a=""><e path="Bool"/></f></hasChildNodes>
	<getElementsByTagName set="method"><f a="tag">
	<c path="String"/>
	<c path="js.HtmlCollection"><t path="js.HtmlDom"/></c>
</f></getElementsByTagName>
	<getAttribute set="method"><f a="attr">
	<c path="String"/>
	<c path="String"/>
</f></getAttribute>
	<focus set="method"><f a=""><e path="Void"/></f></focus>
	<firstChild><t path="js.HtmlDom"/></firstChild>
	<dir><c path="String"/></dir>
	<cloneNode set="method"><f a="deep">
	<e path="Bool"/>
	<t path="js.HtmlDom"/>
</f></cloneNode>
	<clientWidth set="null"><c path="Int"/></clientWidth>
	<clientHeight set="null"><c path="Int"/></clientHeight>
	<click set="method"><f a=""><e path="Void"/></f></click>
	<className><c path="String"/></className>
	<childNodes><c path="js.HtmlCollection"><t path="js.HtmlDom"/></c></childNodes>
	<blur set="method"><f a=""><e path="Void"/></f></blur>
	<appendChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></appendChild>
</a></typedef>
	<typedef path="js.FormElement" params="" file="/usr/share/haxe/std/js/Dom.hx" module="js.Dom"><a>
	<value><c path="String"/></value>
	<type><c path="String"/></type>
	<title><c path="String"/></title>
	<style><t path="js.Style"/></style>
	<setAttribute set="method"><f a="attr:val">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></setAttribute>
	<select set="method"><f a=""><e path="Void"/></f></select>
	<scrollWidth set="null"><c path="Int"/></scrollWidth>
	<scrollTop><c path="Int"/></scrollTop>
	<scrollLeft><c path="Int"/></scrollLeft>
	<scrollHeight set="null"><c path="Int"/></scrollHeight>
	<replaceChild set="method"><f a="child:oldChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></replaceChild>
	<removeChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
</f></removeChild>
	<previousSibling><t path="js.HtmlDom"/></previousSibling>
	<parentNode><t path="js.HtmlDom"/></parentNode>
	<onselect><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onselect>
	<onscroll><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onscroll>
	<onresize><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onresize>
	<onmouseup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseup>
	<onmouseover><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseover>
	<onmouseout><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseout>
	<onmousemove><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousemove>
	<onmousedown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousedown>
	<onkeyup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeyup>
	<onkeypress><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeypress>
	<onkeydown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeydown>
	<onfocus><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onfocus>
	<ondblclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></ondblclick>
	<onclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onclick>
	<onchange><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onchange>
	<onblur><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onblur>
	<offsetWidth><c path="Int"/></offsetWidth>
	<offsetTop><c path="Int"/></offsetTop>
	<offsetParent><t path="js.HtmlDom"/></offsetParent>
	<offsetLeft><c path="Int"/></offsetLeft>
	<offsetHeight><c path="Int"/></offsetHeight>
	<nodeValue><c path="String"/></nodeValue>
	<nodeType><c path="Int"/></nodeType>
	<nodeName><c path="String"/></nodeName>
	<nextSibling><t path="js.HtmlDom"/></nextSibling>
	<name><c path="String"/></name>
	<lastChild><t path="js.HtmlDom"/></lastChild>
	<lang><c path="String"/></lang>
	<insertBefore set="method"><f a="newChild:refChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></insertBefore>
	<innerHTML><c path="String"/></innerHTML>
	<id><c path="String"/></id>
	<hasChildNodes set="method"><f a=""><e path="Bool"/></f></hasChildNodes>
	<getElementsByTagName set="method"><f a="tag">
	<c path="String"/>
	<c path="js.HtmlCollection"><t path="js.HtmlDom"/></c>
</f></getElementsByTagName>
	<getAttribute set="method"><f a="attr">
	<c path="String"/>
	<c path="String"/>
</f></getAttribute>
	<form><t path="js.Form"/></form>
	<focus set="method"><f a=""><e path="Void"/></f></focus>
	<firstChild><t path="js.HtmlDom"/></firstChild>
	<disabled><e path="Bool"/></disabled>
	<dir><c path="String"/></dir>
	<cloneNode set="method"><f a="deep">
	<e path="Bool"/>
	<t path="js.HtmlDom"/>
</f></cloneNode>
	<clientWidth set="null"><c path="Int"/></clientWidth>
	<clientHeight set="null"><c path="Int"/></clientHeight>
	<click set="method"><f a=""><e path="Void"/></f></click>
	<className><c path="String"/></className>
	<childNodes><c path="js.HtmlCollection"><t path="js.HtmlDom"/></c></childNodes>
	<blur set="method"><f a=""><e path="Void"/></f></blur>
	<appendChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></appendChild>
</a></typedef>
	<typedef path="js.Anchor" params="" file="/usr/share/haxe/std/js/Dom.hx" module="js.Dom"><a>
	<title><c path="String"/></title>
	<target><c path="String"/></target>
	<tabIndex><c path="Int"/></tabIndex>
	<style><t path="js.Style"/></style>
	<setAttribute set="method"><f a="attr:val">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></setAttribute>
	<scrollWidth set="null"><c path="Int"/></scrollWidth>
	<scrollTop><c path="Int"/></scrollTop>
	<scrollLeft><c path="Int"/></scrollLeft>
	<scrollHeight set="null"><c path="Int"/></scrollHeight>
	<rev><c path="String"/></rev>
	<replaceChild set="method"><f a="child:oldChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></replaceChild>
	<removeChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
</f></removeChild>
	<rel><c path="String"/></rel>
	<previousSibling><t path="js.HtmlDom"/></previousSibling>
	<parentNode><t path="js.HtmlDom"/></parentNode>
	<onscroll><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onscroll>
	<onresize><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onresize>
	<onmouseup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseup>
	<onmouseover><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseover>
	<onmouseout><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseout>
	<onmousemove><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousemove>
	<onmousedown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousedown>
	<onkeyup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeyup>
	<onkeypress><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeypress>
	<onkeydown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeydown>
	<onfocus><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onfocus>
	<ondblclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></ondblclick>
	<onclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onclick>
	<onblur><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onblur>
	<offsetWidth><c path="Int"/></offsetWidth>
	<offsetTop><c path="Int"/></offsetTop>
	<offsetParent><t path="js.HtmlDom"/></offsetParent>
	<offsetLeft><c path="Int"/></offsetLeft>
	<offsetHeight><c path="Int"/></offsetHeight>
	<nodeValue><c path="String"/></nodeValue>
	<nodeType><c path="Int"/></nodeType>
	<nodeName><c path="String"/></nodeName>
	<nextSibling><t path="js.HtmlDom"/></nextSibling>
	<name><c path="String"/></name>
	<lastChild><t path="js.HtmlDom"/></lastChild>
	<lang><c path="String"/></lang>
	<insertBefore set="method"><f a="newChild:refChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></insertBefore>
	<innerHTML><c path="String"/></innerHTML>
	<id><c path="String"/></id>
	<href><c path="String"/></href>
	<hasChildNodes set="method"><f a=""><e path="Bool"/></f></hasChildNodes>
	<getElementsByTagName set="method"><f a="tag">
	<c path="String"/>
	<c path="js.HtmlCollection"><t path="js.HtmlDom"/></c>
</f></getElementsByTagName>
	<getAttribute set="method"><f a="attr">
	<c path="String"/>
	<c path="String"/>
</f></getAttribute>
	<focus set="method"><f a=""><e path="Void"/></f></focus>
	<firstChild><t path="js.HtmlDom"/></firstChild>
	<dir><c path="String"/></dir>
	<cloneNode set="method"><f a="deep">
	<e path="Bool"/>
	<t path="js.HtmlDom"/>
</f></cloneNode>
	<clientWidth set="null"><c path="Int"/></clientWidth>
	<clientHeight set="null"><c path="Int"/></clientHeight>
	<click set="method"><f a=""><e path="Void"/></f></click>
	<className><c path="String"/></className>
	<childNodes><c path="js.HtmlCollection"><t path="js.HtmlDom"/></c></childNodes>
	<blur set="method"><f a=""><e path="Void"/></f></blur>
	<appendChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></appendChild>
	<accessKey><c path="String"/></accessKey>
</a></typedef>
	<typedef path="js.Body" params="" file="/usr/share/haxe/std/js/Dom.hx" module="js.Dom"><a>
	<vLink><c path="String"/></vLink>
	<title><c path="String"/></title>
	<text><c path="String"/></text>
	<style><t path="js.Style"/></style>
	<setAttribute set="method"><f a="attr:val">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></setAttribute>
	<scrollWidth set="null"><c path="Int"/></scrollWidth>
	<scrollTop><c path="Int"/></scrollTop>
	<scrollLeft><c path="Int"/></scrollLeft>
	<scrollHeight set="null"><c path="Int"/></scrollHeight>
	<replaceChild set="method"><f a="child:oldChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></replaceChild>
	<removeChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
</f></removeChild>
	<previousSibling><t path="js.HtmlDom"/></previousSibling>
	<parentNode><t path="js.HtmlDom"/></parentNode>
	<onscroll><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onscroll>
	<onresize><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onresize>
	<onmouseup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseup>
	<onmouseover><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseover>
	<onmouseout><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseout>
	<onmousemove><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousemove>
	<onmousedown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousedown>
	<onkeyup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeyup>
	<onkeypress><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeypress>
	<onkeydown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeydown>
	<onfocus><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onfocus>
	<ondblclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></ondblclick>
	<onclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onclick>
	<onblur><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onblur>
	<offsetWidth><c path="Int"/></offsetWidth>
	<offsetTop><c path="Int"/></offsetTop>
	<offsetParent><t path="js.HtmlDom"/></offsetParent>
	<offsetLeft><c path="Int"/></offsetLeft>
	<offsetHeight><c path="Int"/></offsetHeight>
	<nodeValue><c path="String"/></nodeValue>
	<nodeType><c path="Int"/></nodeType>
	<nodeName><c path="String"/></nodeName>
	<nextSibling><t path="js.HtmlDom"/></nextSibling>
	<link><c path="String"/></link>
	<lastChild><t path="js.HtmlDom"/></lastChild>
	<lang><c path="String"/></lang>
	<insertBefore set="method"><f a="newChild:refChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></insertBefore>
	<innerHTML><c path="String"/></innerHTML>
	<id><c path="String"/></id>
	<hasChildNodes set="method"><f a=""><e path="Bool"/></f></hasChildNodes>
	<getElementsByTagName set="method"><f a="tag">
	<c path="String"/>
	<c path="js.HtmlCollection"><t path="js.HtmlDom"/></c>
</f></getElementsByTagName>
	<getAttribute set="method"><f a="attr">
	<c path="String"/>
	<c path="String"/>
</f></getAttribute>
	<focus set="method"><f a=""><e path="Void"/></f></focus>
	<firstChild><t path="js.HtmlDom"/></firstChild>
	<dir><c path="String"/></dir>
	<cloneNode set="method"><f a="deep">
	<e path="Bool"/>
	<t path="js.HtmlDom"/>
</f></cloneNode>
	<clientWidth set="null"><c path="Int"/></clientWidth>
	<clientHeight set="null"><c path="Int"/></clientHeight>
	<click set="method"><f a=""><e path="Void"/></f></click>
	<className><c path="String"/></className>
	<childNodes><c path="js.HtmlCollection"><t path="js.HtmlDom"/></c></childNodes>
	<blur set="method"><f a=""><e path="Void"/></f></blur>
	<bgColor><c path="String"/></bgColor>
	<background><c path="String"/></background>
	<appendChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></appendChild>
	<aLink><c path="String"/></aLink>
</a></typedef>
	<typedef path="js.Button" params="" file="/usr/share/haxe/std/js/Dom.hx" module="js.Dom"><a>
	<value><c path="String"/></value>
	<type><c path="String"/></type>
	<title><c path="String"/></title>
	<style><t path="js.Style"/></style>
	<setAttribute set="method"><f a="attr:val">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></setAttribute>
	<select set="method"><f a=""><e path="Void"/></f></select>
	<scrollWidth set="null"><c path="Int"/></scrollWidth>
	<scrollTop><c path="Int"/></scrollTop>
	<scrollLeft><c path="Int"/></scrollLeft>
	<scrollHeight set="null"><c path="Int"/></scrollHeight>
	<replaceChild set="method"><f a="child:oldChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></replaceChild>
	<removeChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
</f></removeChild>
	<previousSibling><t path="js.HtmlDom"/></previousSibling>
	<parentNode><t path="js.HtmlDom"/></parentNode>
	<onselect><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onselect>
	<onscroll><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onscroll>
	<onresize><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onresize>
	<onmouseup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseup>
	<onmouseover><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseover>
	<onmouseout><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseout>
	<onmousemove><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousemove>
	<onmousedown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousedown>
	<onkeyup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeyup>
	<onkeypress><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeypress>
	<onkeydown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeydown>
	<onfocus><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onfocus>
	<ondblclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></ondblclick>
	<onclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onclick>
	<onchange><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onchange>
	<onblur><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onblur>
	<offsetWidth><c path="Int"/></offsetWidth>
	<offsetTop><c path="Int"/></offsetTop>
	<offsetParent><t path="js.HtmlDom"/></offsetParent>
	<offsetLeft><c path="Int"/></offsetLeft>
	<offsetHeight><c path="Int"/></offsetHeight>
	<nodeValue><c path="String"/></nodeValue>
	<nodeType><c path="Int"/></nodeType>
	<nodeName><c path="String"/></nodeName>
	<nextSibling><t path="js.HtmlDom"/></nextSibling>
	<name><c path="String"/></name>
	<lastChild><t path="js.HtmlDom"/></lastChild>
	<lang><c path="String"/></lang>
	<insertBefore set="method"><f a="newChild:refChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></insertBefore>
	<innerHTML><c path="String"/></innerHTML>
	<id><c path="String"/></id>
	<hasChildNodes set="method"><f a=""><e path="Bool"/></f></hasChildNodes>
	<getElementsByTagName set="method"><f a="tag">
	<c path="String"/>
	<c path="js.HtmlCollection"><t path="js.HtmlDom"/></c>
</f></getElementsByTagName>
	<getAttribute set="method"><f a="attr">
	<c path="String"/>
	<c path="String"/>
</f></getAttribute>
	<form><t path="js.Form"/></form>
	<focus set="method"><f a=""><e path="Void"/></f></focus>
	<firstChild><t path="js.HtmlDom"/></firstChild>
	<disabled><e path="Bool"/></disabled>
	<dir><c path="String"/></dir>
	<cloneNode set="method"><f a="deep">
	<e path="Bool"/>
	<t path="js.HtmlDom"/>
</f></cloneNode>
	<clientWidth set="null"><c path="Int"/></clientWidth>
	<clientHeight set="null"><c path="Int"/></clientHeight>
	<click set="method"><f a=""><e path="Void"/></f></click>
	<className><c path="String"/></className>
	<childNodes><c path="js.HtmlCollection"><t path="js.HtmlDom"/></c></childNodes>
	<blur set="method"><f a=""><e path="Void"/></f></blur>
	<appendChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></appendChild>
</a></typedef>
	<typedef path="js.Checkbox" params="" file="/usr/share/haxe/std/js/Dom.hx" module="js.Dom"><a>
	<value><c path="String"/></value>
	<type><c path="String"/></type>
	<title><c path="String"/></title>
	<style><t path="js.Style"/></style>
	<setAttribute set="method"><f a="attr:val">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></setAttribute>
	<select set="method"><f a=""><e path="Void"/></f></select>
	<scrollWidth set="null"><c path="Int"/></scrollWidth>
	<scrollTop><c path="Int"/></scrollTop>
	<scrollLeft><c path="Int"/></scrollLeft>
	<scrollHeight set="null"><c path="Int"/></scrollHeight>
	<replaceChild set="method"><f a="child:oldChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></replaceChild>
	<removeChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
</f></removeChild>
	<previousSibling><t path="js.HtmlDom"/></previousSibling>
	<parentNode><t path="js.HtmlDom"/></parentNode>
	<onselect><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onselect>
	<onscroll><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onscroll>
	<onresize><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onresize>
	<onmouseup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseup>
	<onmouseover><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseover>
	<onmouseout><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseout>
	<onmousemove><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousemove>
	<onmousedown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousedown>
	<onkeyup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeyup>
	<onkeypress><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeypress>
	<onkeydown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeydown>
	<onfocus><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onfocus>
	<ondblclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></ondblclick>
	<onclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onclick>
	<onchange><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onchange>
	<onblur><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onblur>
	<offsetWidth><c path="Int"/></offsetWidth>
	<offsetTop><c path="Int"/></offsetTop>
	<offsetParent><t path="js.HtmlDom"/></offsetParent>
	<offsetLeft><c path="Int"/></offsetLeft>
	<offsetHeight><c path="Int"/></offsetHeight>
	<nodeValue><c path="String"/></nodeValue>
	<nodeType><c path="Int"/></nodeType>
	<nodeName><c path="String"/></nodeName>
	<nextSibling><t path="js.HtmlDom"/></nextSibling>
	<name><c path="String"/></name>
	<lastChild><t path="js.HtmlDom"/></lastChild>
	<lang><c path="String"/></lang>
	<insertBefore set="method"><f a="newChild:refChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></insertBefore>
	<innerHTML><c path="String"/></innerHTML>
	<id><c path="String"/></id>
	<hasChildNodes set="method"><f a=""><e path="Bool"/></f></hasChildNodes>
	<getElementsByTagName set="method"><f a="tag">
	<c path="String"/>
	<c path="js.HtmlCollection"><t path="js.HtmlDom"/></c>
</f></getElementsByTagName>
	<getAttribute set="method"><f a="attr">
	<c path="String"/>
	<c path="String"/>
</f></getAttribute>
	<form><t path="js.Form"/></form>
	<focus set="method"><f a=""><e path="Void"/></f></focus>
	<firstChild><t path="js.HtmlDom"/></firstChild>
	<disabled><e path="Bool"/></disabled>
	<dir><c path="String"/></dir>
	<defaultChecked><e path="Bool"/></defaultChecked>
	<cloneNode set="method"><f a="deep">
	<e path="Bool"/>
	<t path="js.HtmlDom"/>
</f></cloneNode>
	<clientWidth set="null"><c path="Int"/></clientWidth>
	<clientHeight set="null"><c path="Int"/></clientHeight>
	<click set="method"><f a=""><e path="Void"/></f></click>
	<className><c path="String"/></className>
	<childNodes><c path="js.HtmlCollection"><t path="js.HtmlDom"/></c></childNodes>
	<checked><e path="Bool"/></checked>
	<blur set="method"><f a=""><e path="Void"/></f></blur>
	<appendChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></appendChild>
</a></typedef>
	<typedef path="js.Document" params="" file="/usr/share/haxe/std/js/Dom.hx" module="js.Dom"><a>
	<writeln set="method"><f a="str">
	<c path="String"/>
	<e path="Void"/>
</f></writeln>
	<write set="method"><f a="str">
	<c path="String"/>
	<e path="Void"/>
</f></write>
	<title><c path="String"/></title>
	<styleSheets><c path="js.HtmlCollection"><t path="js.StyleSheet"/></c></styleSheets>
	<style><t path="js.Style"/></style>
	<setAttribute set="method"><f a="attr:val">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></setAttribute>
	<scrollWidth set="null"><c path="Int"/></scrollWidth>
	<scrollTop><c path="Int"/></scrollTop>
	<scrollLeft><c path="Int"/></scrollLeft>
	<scrollHeight set="null"><c path="Int"/></scrollHeight>
	<replaceChild set="method"><f a="child:oldChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></replaceChild>
	<removeChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
</f></removeChild>
	<referrer><c path="String"/></referrer>
	<previousSibling><t path="js.HtmlDom"/></previousSibling>
	<parentNode><t path="js.HtmlDom"/></parentNode>
	<open set="method"><f a=""><e path="Void"/></f></open>
	<onscroll><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onscroll>
	<onresize><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onresize>
	<onmouseup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseup>
	<onmouseover><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseover>
	<onmouseout><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseout>
	<onmousemove><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousemove>
	<onmousedown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousedown>
	<onkeyup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeyup>
	<onkeypress><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeypress>
	<onkeydown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeydown>
	<onfocus><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onfocus>
	<ondblclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></ondblclick>
	<onclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onclick>
	<onblur><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onblur>
	<offsetWidth><c path="Int"/></offsetWidth>
	<offsetTop><c path="Int"/></offsetTop>
	<offsetParent><t path="js.HtmlDom"/></offsetParent>
	<offsetLeft><c path="Int"/></offsetLeft>
	<offsetHeight><c path="Int"/></offsetHeight>
	<nodeValue><c path="String"/></nodeValue>
	<nodeType><c path="Int"/></nodeType>
	<nodeName><c path="String"/></nodeName>
	<nextSibling><t path="js.HtmlDom"/></nextSibling>
	<links><c path="js.HtmlCollection"><t path="js.Link"/></c></links>
	<lastChild><t path="js.HtmlDom"/></lastChild>
	<lang><c path="String"/></lang>
	<insertBefore set="method"><f a="newChild:refChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></insertBefore>
	<innerHTML><c path="String"/></innerHTML>
	<images><c path="js.HtmlCollection"><t path="js.Image"/></c></images>
	<id><c path="String"/></id>
	<hasChildNodes set="method"><f a=""><e path="Bool"/></f></hasChildNodes>
	<getElementsByTagName set="method"><f a="tag">
	<c path="String"/>
	<c path="js.HtmlCollection"><t path="js.HtmlDom"/></c>
</f></getElementsByTagName>
	<getElementsByTag set="method"><f a="tag">
	<c path="String"/>
	<c path="js.HtmlCollection"><t path="js.HtmlDom"/></c>
</f></getElementsByTag>
	<getElementsByName set="method"><f a="name">
	<c path="String"/>
	<c path="js.HtmlCollection"><t path="js.HtmlDom"/></c>
</f></getElementsByName>
	<getElementById set="method"><f a="id">
	<c path="String"/>
	<t path="js.HtmlDom"/>
</f></getElementById>
	<getAttribute set="method"><f a="attr">
	<c path="String"/>
	<c path="String"/>
</f></getAttribute>
	<forms><c path="js.HtmlCollection"><t path="js.Form"/></c></forms>
	<focus set="method"><f a=""><e path="Void"/></f></focus>
	<firstChild><t path="js.HtmlDom"/></firstChild>
	<domain><c path="String"/></domain>
	<dir><c path="String"/></dir>
	<createTextNode set="method"><f a="text">
	<c path="String"/>
	<t path="js.HtmlDom"/>
</f></createTextNode>
	<createElement set="method"><f a="name">
	<c path="String"/>
	<t path="js.HtmlDom"/>
</f></createElement>
	<cookie><c path="String"/></cookie>
	<close set="method"><f a=""><e path="Void"/></f></close>
	<cloneNode set="method"><f a="deep">
	<e path="Bool"/>
	<t path="js.HtmlDom"/>
</f></cloneNode>
	<clientWidth set="null"><c path="Int"/></clientWidth>
	<clientHeight set="null"><c path="Int"/></clientHeight>
	<click set="method"><f a=""><e path="Void"/></f></click>
	<className><c path="String"/></className>
	<childNodes><c path="js.HtmlCollection"><t path="js.HtmlDom"/></c></childNodes>
	<body><t path="js.Body"/></body>
	<blur set="method"><f a=""><e path="Void"/></f></blur>
	<appendChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></appendChild>
	<anchors><c path="js.HtmlCollection"><t path="js.Anchor"/></c></anchors>
	<activeElement><t path="js.HtmlDom"/></activeElement>
</a></typedef>
	<typedef path="js.Event" params="" file="/usr/share/haxe/std/js/Dom.hx" module="js.Dom"><a>
	<type><c path="String"/></type>
	<target><t path="js.HtmlDom"/></target>
	<stopPropagation set="method"><f a=""><e path="Void"/></f></stopPropagation>
	<shiftKey><e path="Bool"/></shiftKey>
	<screenY><c path="Int"/></screenY>
	<screenX><c path="Int"/></screenX>
	<keyCode><c path="Int"/></keyCode>
	<ctrlKey><e path="Bool"/></ctrlKey>
	<clientY><c path="Int"/></clientY>
	<clientX><c path="Int"/></clientX>
	<cancelBubble><e path="Bool"/></cancelBubble>
	<button><c path="Int"/></button>
	<altKey><e path="Bool"/></altKey>
</a></typedef>
	<typedef path="js.FileUpload" params="" file="/usr/share/haxe/std/js/Dom.hx" module="js.Dom"><a>
	<value><c path="String"/></value>
	<type><c path="String"/></type>
	<title><c path="String"/></title>
	<style><t path="js.Style"/></style>
	<setAttribute set="method"><f a="attr:val">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></setAttribute>
	<select set="method"><f a=""><e path="Void"/></f></select>
	<scrollWidth set="null"><c path="Int"/></scrollWidth>
	<scrollTop><c path="Int"/></scrollTop>
	<scrollLeft><c path="Int"/></scrollLeft>
	<scrollHeight set="null"><c path="Int"/></scrollHeight>
	<replaceChild set="method"><f a="child:oldChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></replaceChild>
	<removeChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
</f></removeChild>
	<previousSibling><t path="js.HtmlDom"/></previousSibling>
	<parentNode><t path="js.HtmlDom"/></parentNode>
	<onselect><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onselect>
	<onscroll><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onscroll>
	<onresize><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onresize>
	<onmouseup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseup>
	<onmouseover><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseover>
	<onmouseout><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseout>
	<onmousemove><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousemove>
	<onmousedown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousedown>
	<onkeyup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeyup>
	<onkeypress><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeypress>
	<onkeydown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeydown>
	<onfocus><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onfocus>
	<ondblclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></ondblclick>
	<onclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onclick>
	<onchange><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onchange>
	<onblur><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onblur>
	<offsetWidth><c path="Int"/></offsetWidth>
	<offsetTop><c path="Int"/></offsetTop>
	<offsetParent><t path="js.HtmlDom"/></offsetParent>
	<offsetLeft><c path="Int"/></offsetLeft>
	<offsetHeight><c path="Int"/></offsetHeight>
	<nodeValue><c path="String"/></nodeValue>
	<nodeType><c path="Int"/></nodeType>
	<nodeName><c path="String"/></nodeName>
	<nextSibling><t path="js.HtmlDom"/></nextSibling>
	<name><c path="String"/></name>
	<lastChild><t path="js.HtmlDom"/></lastChild>
	<lang><c path="String"/></lang>
	<insertBefore set="method"><f a="newChild:refChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></insertBefore>
	<innerHTML><c path="String"/></innerHTML>
	<id><c path="String"/></id>
	<hasChildNodes set="method"><f a=""><e path="Bool"/></f></hasChildNodes>
	<getElementsByTagName set="method"><f a="tag">
	<c path="String"/>
	<c path="js.HtmlCollection"><t path="js.HtmlDom"/></c>
</f></getElementsByTagName>
	<getAttribute set="method"><f a="attr">
	<c path="String"/>
	<c path="String"/>
</f></getAttribute>
	<form><t path="js.Form"/></form>
	<focus set="method"><f a=""><e path="Void"/></f></focus>
	<firstChild><t path="js.HtmlDom"/></firstChild>
	<disabled><e path="Bool"/></disabled>
	<dir><c path="String"/></dir>
	<defaultValue><c path="String"/></defaultValue>
	<cloneNode set="method"><f a="deep">
	<e path="Bool"/>
	<t path="js.HtmlDom"/>
</f></cloneNode>
	<clientWidth set="null"><c path="Int"/></clientWidth>
	<clientHeight set="null"><c path="Int"/></clientHeight>
	<click set="method"><f a=""><e path="Void"/></f></click>
	<className><c path="String"/></className>
	<childNodes><c path="js.HtmlCollection"><t path="js.HtmlDom"/></c></childNodes>
	<blur set="method"><f a=""><e path="Void"/></f></blur>
	<appendChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></appendChild>
</a></typedef>
	<typedef path="js.Form" params="" file="/usr/share/haxe/std/js/Dom.hx" module="js.Dom"><a>
	<title><c path="String"/></title>
	<target><c path="String"/></target>
	<tabIndex><c path="Int"/></tabIndex>
	<submit set="method"><f a=""><e path="Void"/></f></submit>
	<style><t path="js.Style"/></style>
	<setAttribute set="method"><f a="attr:val">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></setAttribute>
	<scrollWidth set="null"><c path="Int"/></scrollWidth>
	<scrollTop><c path="Int"/></scrollTop>
	<scrollLeft><c path="Int"/></scrollLeft>
	<scrollHeight set="null"><c path="Int"/></scrollHeight>
	<reset set="method"><f a=""><e path="Void"/></f></reset>
	<replaceChild set="method"><f a="child:oldChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></replaceChild>
	<removeChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
</f></removeChild>
	<previousSibling><t path="js.HtmlDom"/></previousSibling>
	<parentNode><t path="js.HtmlDom"/></parentNode>
	<onsubmit><f a="">
	<t path="js.Event"/>
	<e path="Bool"/>
</f></onsubmit>
	<onscroll><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onscroll>
	<onresize><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onresize>
	<onreset><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onreset>
	<onmouseup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseup>
	<onmouseover><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseover>
	<onmouseout><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseout>
	<onmousemove><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousemove>
	<onmousedown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousedown>
	<onkeyup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeyup>
	<onkeypress><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeypress>
	<onkeydown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeydown>
	<onfocus><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onfocus>
	<ondblclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></ondblclick>
	<onclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onclick>
	<onblur><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onblur>
	<offsetWidth><c path="Int"/></offsetWidth>
	<offsetTop><c path="Int"/></offsetTop>
	<offsetParent><t path="js.HtmlDom"/></offsetParent>
	<offsetLeft><c path="Int"/></offsetLeft>
	<offsetHeight><c path="Int"/></offsetHeight>
	<nodeValue><c path="String"/></nodeValue>
	<nodeType><c path="Int"/></nodeType>
	<nodeName><c path="String"/></nodeName>
	<nextSibling><t path="js.HtmlDom"/></nextSibling>
	<name><c path="String"/></name>
	<method><c path="String"/></method>
	<length><c path="Int"/></length>
	<lastChild><t path="js.HtmlDom"/></lastChild>
	<lang><c path="String"/></lang>
	<insertBefore set="method"><f a="newChild:refChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></insertBefore>
	<innerHTML><c path="String"/></innerHTML>
	<id><c path="String"/></id>
	<hasChildNodes set="method"><f a=""><e path="Bool"/></f></hasChildNodes>
	<getElementsByTagName set="method"><f a="tag">
	<c path="String"/>
	<c path="js.HtmlCollection"><t path="js.HtmlDom"/></c>
</f></getElementsByTagName>
	<getAttribute set="method"><f a="attr">
	<c path="String"/>
	<c path="String"/>
</f></getAttribute>
	<focus set="method"><f a=""><e path="Void"/></f></focus>
	<firstChild><t path="js.HtmlDom"/></firstChild>
	<enctype><c path="String"/></enctype>
	<encoding><c path="String"/></encoding>
	<elements><c path="js.HtmlCollection"><t path="js.FormElement"/></c></elements>
	<dir><c path="String"/></dir>
	<cloneNode set="method"><f a="deep">
	<e path="Bool"/>
	<t path="js.HtmlDom"/>
</f></cloneNode>
	<clientWidth set="null"><c path="Int"/></clientWidth>
	<clientHeight set="null"><c path="Int"/></clientHeight>
	<click set="method"><f a=""><e path="Void"/></f></click>
	<className><c path="String"/></className>
	<childNodes><c path="js.HtmlCollection"><t path="js.HtmlDom"/></c></childNodes>
	<blur set="method"><f a=""><e path="Void"/></f></blur>
	<appendChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></appendChild>
	<action><c path="String"/></action>
	<acceptCharset><c path="String"/></acceptCharset>
</a></typedef>
	<typedef path="js.Frame" params="" file="/usr/share/haxe/std/js/Dom.hx" module="js.Dom"><a>
	<title><c path="String"/></title>
	<style><t path="js.Style"/></style>
	<src><c path="String"/></src>
	<setAttribute set="method"><f a="attr:val">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></setAttribute>
	<scrolling><c path="String"/></scrolling>
	<scrollWidth set="null"><c path="Int"/></scrollWidth>
	<scrollTop><c path="Int"/></scrollTop>
	<scrollLeft><c path="Int"/></scrollLeft>
	<scrollHeight set="null"><c path="Int"/></scrollHeight>
	<replaceChild set="method"><f a="child:oldChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></replaceChild>
	<removeChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
</f></removeChild>
	<previousSibling><t path="js.HtmlDom"/></previousSibling>
	<parentNode><t path="js.HtmlDom"/></parentNode>
	<onscroll><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onscroll>
	<onresize><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onresize>
	<onmouseup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseup>
	<onmouseover><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseover>
	<onmouseout><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseout>
	<onmousemove><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousemove>
	<onmousedown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousedown>
	<onkeyup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeyup>
	<onkeypress><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeypress>
	<onkeydown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeydown>
	<onfocus><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onfocus>
	<ondblclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></ondblclick>
	<onclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onclick>
	<onblur><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onblur>
	<offsetWidth><c path="Int"/></offsetWidth>
	<offsetTop><c path="Int"/></offsetTop>
	<offsetParent><t path="js.HtmlDom"/></offsetParent>
	<offsetLeft><c path="Int"/></offsetLeft>
	<offsetHeight><c path="Int"/></offsetHeight>
	<nodeValue><c path="String"/></nodeValue>
	<nodeType><c path="Int"/></nodeType>
	<nodeName><c path="String"/></nodeName>
	<noResize><e path="Bool"/></noResize>
	<nextSibling><t path="js.HtmlDom"/></nextSibling>
	<name><c path="String"/></name>
	<marginWidth><c path="String"/></marginWidth>
	<marginHeight><c path="String"/></marginHeight>
	<lastChild><t path="js.HtmlDom"/></lastChild>
	<lang><c path="String"/></lang>
	<insertBefore set="method"><f a="newChild:refChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></insertBefore>
	<innerHTML><c path="String"/></innerHTML>
	<id><c path="String"/></id>
	<hasChildNodes set="method"><f a=""><e path="Bool"/></f></hasChildNodes>
	<getElementsByTagName set="method"><f a="tag">
	<c path="String"/>
	<c path="js.HtmlCollection"><t path="js.HtmlDom"/></c>
</f></getElementsByTagName>
	<getAttribute set="method"><f a="attr">
	<c path="String"/>
	<c path="String"/>
</f></getAttribute>
	<frameBorder><c path="String"/></frameBorder>
	<focus set="method"><f a=""><e path="Void"/></f></focus>
	<firstChild><t path="js.HtmlDom"/></firstChild>
	<dir><c path="String"/></dir>
	<contentDocument><t path="js.Document"/></contentDocument>
	<cloneNode set="method"><f a="deep">
	<e path="Bool"/>
	<t path="js.HtmlDom"/>
</f></cloneNode>
	<clientWidth set="null"><c path="Int"/></clientWidth>
	<clientHeight set="null"><c path="Int"/></clientHeight>
	<click set="method"><f a=""><e path="Void"/></f></click>
	<className><c path="String"/></className>
	<childNodes><c path="js.HtmlCollection"><t path="js.HtmlDom"/></c></childNodes>
	<blur set="method"><f a=""><e path="Void"/></f></blur>
	<appendChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></appendChild>
</a></typedef>
	<typedef path="js.Frameset" params="" file="/usr/share/haxe/std/js/Dom.hx" module="js.Dom"><a>
	<title><c path="String"/></title>
	<style><t path="js.Style"/></style>
	<setAttribute set="method"><f a="attr:val">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></setAttribute>
	<scrollWidth set="null"><c path="Int"/></scrollWidth>
	<scrollTop><c path="Int"/></scrollTop>
	<scrollLeft><c path="Int"/></scrollLeft>
	<scrollHeight set="null"><c path="Int"/></scrollHeight>
	<rows><c path="Int"/></rows>
	<replaceChild set="method"><f a="child:oldChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></replaceChild>
	<removeChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
</f></removeChild>
	<previousSibling><t path="js.HtmlDom"/></previousSibling>
	<parentNode><t path="js.HtmlDom"/></parentNode>
	<onscroll><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onscroll>
	<onresize><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onresize>
	<onmouseup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseup>
	<onmouseover><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseover>
	<onmouseout><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseout>
	<onmousemove><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousemove>
	<onmousedown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousedown>
	<onkeyup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeyup>
	<onkeypress><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeypress>
	<onkeydown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeydown>
	<onfocus><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onfocus>
	<ondblclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></ondblclick>
	<onclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onclick>
	<onblur><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onblur>
	<offsetWidth><c path="Int"/></offsetWidth>
	<offsetTop><c path="Int"/></offsetTop>
	<offsetParent><t path="js.HtmlDom"/></offsetParent>
	<offsetLeft><c path="Int"/></offsetLeft>
	<offsetHeight><c path="Int"/></offsetHeight>
	<nodeValue><c path="String"/></nodeValue>
	<nodeType><c path="Int"/></nodeType>
	<nodeName><c path="String"/></nodeName>
	<nextSibling><t path="js.HtmlDom"/></nextSibling>
	<lastChild><t path="js.HtmlDom"/></lastChild>
	<lang><c path="String"/></lang>
	<insertBefore set="method"><f a="newChild:refChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></insertBefore>
	<innerHTML><c path="String"/></innerHTML>
	<id><c path="String"/></id>
	<hasChildNodes set="method"><f a=""><e path="Bool"/></f></hasChildNodes>
	<getElementsByTagName set="method"><f a="tag">
	<c path="String"/>
	<c path="js.HtmlCollection"><t path="js.HtmlDom"/></c>
</f></getElementsByTagName>
	<getAttribute set="method"><f a="attr">
	<c path="String"/>
	<c path="String"/>
</f></getAttribute>
	<focus set="method"><f a=""><e path="Void"/></f></focus>
	<firstChild><t path="js.HtmlDom"/></firstChild>
	<dir><c path="String"/></dir>
	<cols><c path="Int"/></cols>
	<cloneNode set="method"><f a="deep">
	<e path="Bool"/>
	<t path="js.HtmlDom"/>
</f></cloneNode>
	<clientWidth set="null"><c path="Int"/></clientWidth>
	<clientHeight set="null"><c path="Int"/></clientHeight>
	<click set="method"><f a=""><e path="Void"/></f></click>
	<className><c path="String"/></className>
	<childNodes><c path="js.HtmlCollection"><t path="js.HtmlDom"/></c></childNodes>
	<blur set="method"><f a=""><e path="Void"/></f></blur>
	<appendChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></appendChild>
</a></typedef>
	<typedef path="js.Hidden" params="" file="/usr/share/haxe/std/js/Dom.hx" module="js.Dom"><a>
	<value><c path="String"/></value>
	<type><c path="String"/></type>
	<title><c path="String"/></title>
	<style><t path="js.Style"/></style>
	<setAttribute set="method"><f a="attr:val">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></setAttribute>
	<select set="method"><f a=""><e path="Void"/></f></select>
	<scrollWidth set="null"><c path="Int"/></scrollWidth>
	<scrollTop><c path="Int"/></scrollTop>
	<scrollLeft><c path="Int"/></scrollLeft>
	<scrollHeight set="null"><c path="Int"/></scrollHeight>
	<replaceChild set="method"><f a="child:oldChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></replaceChild>
	<removeChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
</f></removeChild>
	<previousSibling><t path="js.HtmlDom"/></previousSibling>
	<parentNode><t path="js.HtmlDom"/></parentNode>
	<onselect><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onselect>
	<onscroll><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onscroll>
	<onresize><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onresize>
	<onmouseup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseup>
	<onmouseover><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseover>
	<onmouseout><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseout>
	<onmousemove><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousemove>
	<onmousedown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousedown>
	<onkeyup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeyup>
	<onkeypress><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeypress>
	<onkeydown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeydown>
	<onfocus><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onfocus>
	<ondblclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></ondblclick>
	<onclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onclick>
	<onchange><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onchange>
	<onblur><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onblur>
	<offsetWidth><c path="Int"/></offsetWidth>
	<offsetTop><c path="Int"/></offsetTop>
	<offsetParent><t path="js.HtmlDom"/></offsetParent>
	<offsetLeft><c path="Int"/></offsetLeft>
	<offsetHeight><c path="Int"/></offsetHeight>
	<nodeValue><c path="String"/></nodeValue>
	<nodeType><c path="Int"/></nodeType>
	<nodeName><c path="String"/></nodeName>
	<nextSibling><t path="js.HtmlDom"/></nextSibling>
	<name><c path="String"/></name>
	<lastChild><t path="js.HtmlDom"/></lastChild>
	<lang><c path="String"/></lang>
	<insertBefore set="method"><f a="newChild:refChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></insertBefore>
	<innerHTML><c path="String"/></innerHTML>
	<id><c path="String"/></id>
	<hasChildNodes set="method"><f a=""><e path="Bool"/></f></hasChildNodes>
	<getElementsByTagName set="method"><f a="tag">
	<c path="String"/>
	<c path="js.HtmlCollection"><t path="js.HtmlDom"/></c>
</f></getElementsByTagName>
	<getAttribute set="method"><f a="attr">
	<c path="String"/>
	<c path="String"/>
</f></getAttribute>
	<form><t path="js.Form"/></form>
	<focus set="method"><f a=""><e path="Void"/></f></focus>
	<firstChild><t path="js.HtmlDom"/></firstChild>
	<disabled><e path="Bool"/></disabled>
	<dir><c path="String"/></dir>
	<defaultValue><c path="String"/></defaultValue>
	<cloneNode set="method"><f a="deep">
	<e path="Bool"/>
	<t path="js.HtmlDom"/>
</f></cloneNode>
	<clientWidth set="null"><c path="Int"/></clientWidth>
	<clientHeight set="null"><c path="Int"/></clientHeight>
	<click set="method"><f a=""><e path="Void"/></f></click>
	<className><c path="String"/></className>
	<childNodes><c path="js.HtmlCollection"><t path="js.HtmlDom"/></c></childNodes>
	<blur set="method"><f a=""><e path="Void"/></f></blur>
	<appendChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></appendChild>
</a></typedef>
	<typedef path="js.History" params="" file="/usr/share/haxe/std/js/Dom.hx" module="js.Dom"><a>
	<length><c path="Int"/></length>
	<go set="method"><f a="p">
	<d/>
	<e path="Void"/>
</f></go>
	<forward set="method"><f a=""><e path="Void"/></f></forward>
	<back set="method"><f a=""><e path="Void"/></f></back>
</a></typedef>
	<typedef path="js.IFrame" params="" file="/usr/share/haxe/std/js/Dom.hx" module="js.Dom"><a>
	<width><c path="Int"/></width>
	<title><c path="String"/></title>
	<style><t path="js.Style"/></style>
	<src><c path="String"/></src>
	<setAttribute set="method"><f a="attr:val">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></setAttribute>
	<scrolling><c path="String"/></scrolling>
	<scrollWidth set="null"><c path="Int"/></scrollWidth>
	<scrollTop><c path="Int"/></scrollTop>
	<scrollLeft><c path="Int"/></scrollLeft>
	<scrollHeight set="null"><c path="Int"/></scrollHeight>
	<replaceChild set="method"><f a="child:oldChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></replaceChild>
	<removeChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
</f></removeChild>
	<previousSibling><t path="js.HtmlDom"/></previousSibling>
	<parentNode><t path="js.HtmlDom"/></parentNode>
	<onscroll><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onscroll>
	<onresize><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onresize>
	<onmouseup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseup>
	<onmouseover><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseover>
	<onmouseout><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseout>
	<onmousemove><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousemove>
	<onmousedown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousedown>
	<onkeyup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeyup>
	<onkeypress><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeypress>
	<onkeydown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeydown>
	<onfocus><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onfocus>
	<ondblclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></ondblclick>
	<onclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onclick>
	<onblur><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onblur>
	<offsetWidth><c path="Int"/></offsetWidth>
	<offsetTop><c path="Int"/></offsetTop>
	<offsetParent><t path="js.HtmlDom"/></offsetParent>
	<offsetLeft><c path="Int"/></offsetLeft>
	<offsetHeight><c path="Int"/></offsetHeight>
	<nodeValue><c path="String"/></nodeValue>
	<nodeType><c path="Int"/></nodeType>
	<nodeName><c path="String"/></nodeName>
	<nextSibling><t path="js.HtmlDom"/></nextSibling>
	<name><c path="String"/></name>
	<marginWidth><c path="String"/></marginWidth>
	<marginHeight><c path="String"/></marginHeight>
	<lastChild><t path="js.HtmlDom"/></lastChild>
	<lang><c path="String"/></lang>
	<insertBefore set="method"><f a="newChild:refChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></insertBefore>
	<innerHTML><c path="String"/></innerHTML>
	<id><c path="String"/></id>
	<height><c path="Int"/></height>
	<hasChildNodes set="method"><f a=""><e path="Bool"/></f></hasChildNodes>
	<getElementsByTagName set="method"><f a="tag">
	<c path="String"/>
	<c path="js.HtmlCollection"><t path="js.HtmlDom"/></c>
</f></getElementsByTagName>
	<getAttribute set="method"><f a="attr">
	<c path="String"/>
	<c path="String"/>
</f></getAttribute>
	<frameBorder><c path="String"/></frameBorder>
	<focus set="method"><f a=""><e path="Void"/></f></focus>
	<firstChild><t path="js.HtmlDom"/></firstChild>
	<dir><c path="String"/></dir>
	<contentWindow><t path="js.Window"/></contentWindow>
	<cloneNode set="method"><f a="deep">
	<e path="Bool"/>
	<t path="js.HtmlDom"/>
</f></cloneNode>
	<clientWidth set="null"><c path="Int"/></clientWidth>
	<clientHeight set="null"><c path="Int"/></clientHeight>
	<click set="method"><f a=""><e path="Void"/></f></click>
	<className><c path="String"/></className>
	<childNodes><c path="js.HtmlCollection"><t path="js.HtmlDom"/></c></childNodes>
	<blur set="method"><f a=""><e path="Void"/></f></blur>
	<appendChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></appendChild>
</a></typedef>
	<typedef path="js.Image" params="" file="/usr/share/haxe/std/js/Dom.hx" module="js.Dom"><a>
	<width><c path="Int"/></width>
	<vspace><c path="Int"/></vspace>
	<useMap><c path="String"/></useMap>
	<title><c path="String"/></title>
	<style><t path="js.Style"/></style>
	<src><c path="String"/></src>
	<setAttribute set="method"><f a="attr:val">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></setAttribute>
	<scrollWidth set="null"><c path="Int"/></scrollWidth>
	<scrollTop><c path="Int"/></scrollTop>
	<scrollLeft><c path="Int"/></scrollLeft>
	<scrollHeight set="null"><c path="Int"/></scrollHeight>
	<replaceChild set="method"><f a="child:oldChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></replaceChild>
	<removeChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
</f></removeChild>
	<previousSibling><t path="js.HtmlDom"/></previousSibling>
	<parentNode><t path="js.HtmlDom"/></parentNode>
	<onscroll><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onscroll>
	<onresize><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onresize>
	<onmouseup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseup>
	<onmouseover><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseover>
	<onmouseout><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseout>
	<onmousemove><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousemove>
	<onmousedown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousedown>
	<onload><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onload>
	<onkeyup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeyup>
	<onkeypress><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeypress>
	<onkeydown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeydown>
	<onfocus><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onfocus>
	<onerror><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onerror>
	<ondblclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></ondblclick>
	<onclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onclick>
	<onblur><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onblur>
	<onabort><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onabort>
	<offsetWidth><c path="Int"/></offsetWidth>
	<offsetTop><c path="Int"/></offsetTop>
	<offsetParent><t path="js.HtmlDom"/></offsetParent>
	<offsetLeft><c path="Int"/></offsetLeft>
	<offsetHeight><c path="Int"/></offsetHeight>
	<nodeValue><c path="String"/></nodeValue>
	<nodeType><c path="Int"/></nodeType>
	<nodeName><c path="String"/></nodeName>
	<nextSibling><t path="js.HtmlDom"/></nextSibling>
	<name><c path="String"/></name>
	<lowsrc><c path="String"/></lowsrc>
	<lastChild><t path="js.HtmlDom"/></lastChild>
	<lang><c path="String"/></lang>
	<isMap><e path="Bool"/></isMap>
	<insertBefore set="method"><f a="newChild:refChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></insertBefore>
	<innerHTML><c path="String"/></innerHTML>
	<id><c path="String"/></id>
	<hspace><c path="Int"/></hspace>
	<height><c path="Int"/></height>
	<hasChildNodes set="method"><f a=""><e path="Bool"/></f></hasChildNodes>
	<getElementsByTagName set="method"><f a="tag">
	<c path="String"/>
	<c path="js.HtmlCollection"><t path="js.HtmlDom"/></c>
</f></getElementsByTagName>
	<getAttribute set="method"><f a="attr">
	<c path="String"/>
	<c path="String"/>
</f></getAttribute>
	<focus set="method"><f a=""><e path="Void"/></f></focus>
	<firstChild><t path="js.HtmlDom"/></firstChild>
	<dir><c path="String"/></dir>
	<complete><e path="Bool"/></complete>
	<cloneNode set="method"><f a="deep">
	<e path="Bool"/>
	<t path="js.HtmlDom"/>
</f></cloneNode>
	<clientWidth set="null"><c path="Int"/></clientWidth>
	<clientHeight set="null"><c path="Int"/></clientHeight>
	<click set="method"><f a=""><e path="Void"/></f></click>
	<className><c path="String"/></className>
	<childNodes><c path="js.HtmlCollection"><t path="js.HtmlDom"/></c></childNodes>
	<border><c path="String"/></border>
	<blur set="method"><f a=""><e path="Void"/></f></blur>
	<appendChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></appendChild>
	<alt><c path="String"/></alt>
	<align><c path="String"/></align>
</a></typedef>
	<typedef path="js.Link" params="" file="/usr/share/haxe/std/js/Dom.hx" module="js.Dom"><a>
	<type><c path="String"/></type>
	<title><c path="String"/></title>
	<target><c path="String"/></target>
	<style><t path="js.Style"/></style>
	<setAttribute set="method"><f a="attr:val">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></setAttribute>
	<scrollWidth set="null"><c path="Int"/></scrollWidth>
	<scrollTop><c path="Int"/></scrollTop>
	<scrollLeft><c path="Int"/></scrollLeft>
	<scrollHeight set="null"><c path="Int"/></scrollHeight>
	<rev><c path="String"/></rev>
	<replaceChild set="method"><f a="child:oldChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></replaceChild>
	<removeChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
</f></removeChild>
	<rel><c path="String"/></rel>
	<previousSibling><t path="js.HtmlDom"/></previousSibling>
	<parentNode><t path="js.HtmlDom"/></parentNode>
	<onscroll><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onscroll>
	<onresize><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onresize>
	<onmouseup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseup>
	<onmouseover><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseover>
	<onmouseout><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseout>
	<onmousemove><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousemove>
	<onmousedown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousedown>
	<onload><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onload>
	<onkeyup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeyup>
	<onkeypress><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeypress>
	<onkeydown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeydown>
	<onfocus><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onfocus>
	<ondblclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></ondblclick>
	<onclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onclick>
	<onblur><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onblur>
	<offsetWidth><c path="Int"/></offsetWidth>
	<offsetTop><c path="Int"/></offsetTop>
	<offsetParent><t path="js.HtmlDom"/></offsetParent>
	<offsetLeft><c path="Int"/></offsetLeft>
	<offsetHeight><c path="Int"/></offsetHeight>
	<nodeValue><c path="String"/></nodeValue>
	<nodeType><c path="Int"/></nodeType>
	<nodeName><c path="String"/></nodeName>
	<nextSibling><t path="js.HtmlDom"/></nextSibling>
	<name><c path="String"/></name>
	<media><c path="String"/></media>
	<lastChild><t path="js.HtmlDom"/></lastChild>
	<lang><c path="String"/></lang>
	<insertBefore set="method"><f a="newChild:refChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></insertBefore>
	<innerHTML><c path="String"/></innerHTML>
	<id><c path="String"/></id>
	<hreflang><c path="String"/></hreflang>
	<href><c path="String"/></href>
	<hasChildNodes set="method"><f a=""><e path="Bool"/></f></hasChildNodes>
	<getElementsByTagName set="method"><f a="tag">
	<c path="String"/>
	<c path="js.HtmlCollection"><t path="js.HtmlDom"/></c>
</f></getElementsByTagName>
	<getAttribute set="method"><f a="attr">
	<c path="String"/>
	<c path="String"/>
</f></getAttribute>
	<focus set="method"><f a=""><e path="Void"/></f></focus>
	<firstChild><t path="js.HtmlDom"/></firstChild>
	<disabled><e path="Bool"/></disabled>
	<dir><c path="String"/></dir>
	<cloneNode set="method"><f a="deep">
	<e path="Bool"/>
	<t path="js.HtmlDom"/>
</f></cloneNode>
	<clientWidth set="null"><c path="Int"/></clientWidth>
	<clientHeight set="null"><c path="Int"/></clientHeight>
	<click set="method"><f a=""><e path="Void"/></f></click>
	<className><c path="String"/></className>
	<childNodes><c path="js.HtmlCollection"><t path="js.HtmlDom"/></c></childNodes>
	<charset><c path="String"/></charset>
	<blur set="method"><f a=""><e path="Void"/></f></blur>
	<appendChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></appendChild>
</a></typedef>
	<typedef path="js.Location" params="" file="/usr/share/haxe/std/js/Dom.hx" module="js.Dom"><a>
	<search><c path="String"/></search>
	<replace set="method"><f a="url">
	<c path="String"/>
	<e path="Void"/>
</f></replace>
	<reload set="method"><f a="?forceReload">
	<e path="Bool"/>
	<e path="Void"/>
</f></reload>
	<protocol><c path="String"/></protocol>
	<port><c path="Int"/></port>
	<pathname><c path="String"/></pathname>
	<href><c path="String"/></href>
	<hostname><c path="String"/></hostname>
	<host><c path="String"/></host>
	<hash><c path="String"/></hash>
	<assign set="method"><f a="url">
	<c path="String"/>
	<e path="Void"/>
</f></assign>
</a></typedef>
	<typedef path="js.Navigator" params="" file="/usr/share/haxe/std/js/Dom.hx" module="js.Dom"><a>
	<userAgent><c path="String"/></userAgent>
	<taintEnabled set="method"><f a=""><e path="Bool"/></f></taintEnabled>
	<platform><c path="String"/></platform>
	<javaEnabled set="method"><f a=""><e path="Bool"/></f></javaEnabled>
	<cookieEnabled><e path="Bool"/></cookieEnabled>
	<appVersion><c path="String"/></appVersion>
	<appName><c path="String"/></appName>
	<appCodeName><c path="String"/></appCodeName>
</a></typedef>
	<typedef path="js.Option" params="" file="/usr/share/haxe/std/js/Dom.hx" module="js.Dom"><a>
	<value><c path="String"/></value>
	<type><c path="String"/></type>
	<title><c path="String"/></title>
	<text><c path="String"/></text>
	<style><t path="js.Style"/></style>
	<setAttribute set="method"><f a="attr:val">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></setAttribute>
	<selected><e path="Bool"/></selected>
	<select set="method"><f a=""><e path="Void"/></f></select>
	<scrollWidth set="null"><c path="Int"/></scrollWidth>
	<scrollTop><c path="Int"/></scrollTop>
	<scrollLeft><c path="Int"/></scrollLeft>
	<scrollHeight set="null"><c path="Int"/></scrollHeight>
	<replaceChild set="method"><f a="child:oldChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></replaceChild>
	<removeChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
</f></removeChild>
	<previousSibling><t path="js.HtmlDom"/></previousSibling>
	<parentNode><t path="js.HtmlDom"/></parentNode>
	<onselect><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onselect>
	<onscroll><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onscroll>
	<onresize><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onresize>
	<onmouseup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseup>
	<onmouseover><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseover>
	<onmouseout><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseout>
	<onmousemove><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousemove>
	<onmousedown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousedown>
	<onkeyup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeyup>
	<onkeypress><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeypress>
	<onkeydown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeydown>
	<onfocus><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onfocus>
	<ondblclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></ondblclick>
	<onclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onclick>
	<onchange><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onchange>
	<onblur><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onblur>
	<offsetWidth><c path="Int"/></offsetWidth>
	<offsetTop><c path="Int"/></offsetTop>
	<offsetParent><t path="js.HtmlDom"/></offsetParent>
	<offsetLeft><c path="Int"/></offsetLeft>
	<offsetHeight><c path="Int"/></offsetHeight>
	<nodeValue><c path="String"/></nodeValue>
	<nodeType><c path="Int"/></nodeType>
	<nodeName><c path="String"/></nodeName>
	<nextSibling><t path="js.HtmlDom"/></nextSibling>
	<name><c path="String"/></name>
	<lastChild><t path="js.HtmlDom"/></lastChild>
	<lang><c path="String"/></lang>
	<insertBefore set="method"><f a="newChild:refChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></insertBefore>
	<innerHTML><c path="String"/></innerHTML>
	<id><c path="String"/></id>
	<hasChildNodes set="method"><f a=""><e path="Bool"/></f></hasChildNodes>
	<getElementsByTagName set="method"><f a="tag">
	<c path="String"/>
	<c path="js.HtmlCollection"><t path="js.HtmlDom"/></c>
</f></getElementsByTagName>
	<getAttribute set="method"><f a="attr">
	<c path="String"/>
	<c path="String"/>
</f></getAttribute>
	<form><t path="js.Form"/></form>
	<focus set="method"><f a=""><e path="Void"/></f></focus>
	<firstChild><t path="js.HtmlDom"/></firstChild>
	<disabled><e path="Bool"/></disabled>
	<dir><c path="String"/></dir>
	<defaultSelected><e path="Bool"/></defaultSelected>
	<cloneNode set="method"><f a="deep">
	<e path="Bool"/>
	<t path="js.HtmlDom"/>
</f></cloneNode>
	<clientWidth set="null"><c path="Int"/></clientWidth>
	<clientHeight set="null"><c path="Int"/></clientHeight>
	<click set="method"><f a=""><e path="Void"/></f></click>
	<className><c path="String"/></className>
	<childNodes><c path="js.HtmlCollection"><t path="js.HtmlDom"/></c></childNodes>
	<blur set="method"><f a=""><e path="Void"/></f></blur>
	<appendChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></appendChild>
</a></typedef>
	<typedef path="js.Password" params="" file="/usr/share/haxe/std/js/Dom.hx" module="js.Dom"><a>
	<value><c path="String"/></value>
	<type><c path="String"/></type>
	<title><c path="String"/></title>
	<style><t path="js.Style"/></style>
	<size><c path="Int"/></size>
	<setAttribute set="method"><f a="attr:val">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></setAttribute>
	<select set="method"><f a=""><e path="Void"/></f></select>
	<scrollWidth set="null"><c path="Int"/></scrollWidth>
	<scrollTop><c path="Int"/></scrollTop>
	<scrollLeft><c path="Int"/></scrollLeft>
	<scrollHeight set="null"><c path="Int"/></scrollHeight>
	<replaceChild set="method"><f a="child:oldChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></replaceChild>
	<removeChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
</f></removeChild>
	<readOnly><e path="Bool"/></readOnly>
	<previousSibling><t path="js.HtmlDom"/></previousSibling>
	<parentNode><t path="js.HtmlDom"/></parentNode>
	<onselect><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onselect>
	<onscroll><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onscroll>
	<onresize><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onresize>
	<onmouseup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseup>
	<onmouseover><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseover>
	<onmouseout><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseout>
	<onmousemove><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousemove>
	<onmousedown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousedown>
	<onkeyup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeyup>
	<onkeypress><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeypress>
	<onkeydown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeydown>
	<onfocus><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onfocus>
	<ondblclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></ondblclick>
	<onclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onclick>
	<onchange><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onchange>
	<onblur><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onblur>
	<offsetWidth><c path="Int"/></offsetWidth>
	<offsetTop><c path="Int"/></offsetTop>
	<offsetParent><t path="js.HtmlDom"/></offsetParent>
	<offsetLeft><c path="Int"/></offsetLeft>
	<offsetHeight><c path="Int"/></offsetHeight>
	<nodeValue><c path="String"/></nodeValue>
	<nodeType><c path="Int"/></nodeType>
	<nodeName><c path="String"/></nodeName>
	<nextSibling><t path="js.HtmlDom"/></nextSibling>
	<name><c path="String"/></name>
	<maxLength><c path="Int"/></maxLength>
	<lastChild><t path="js.HtmlDom"/></lastChild>
	<lang><c path="String"/></lang>
	<insertBefore set="method"><f a="newChild:refChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></insertBefore>
	<innerHTML><c path="String"/></innerHTML>
	<id><c path="String"/></id>
	<hasChildNodes set="method"><f a=""><e path="Bool"/></f></hasChildNodes>
	<getElementsByTagName set="method"><f a="tag">
	<c path="String"/>
	<c path="js.HtmlCollection"><t path="js.HtmlDom"/></c>
</f></getElementsByTagName>
	<getAttribute set="method"><f a="attr">
	<c path="String"/>
	<c path="String"/>
</f></getAttribute>
	<form><t path="js.Form"/></form>
	<focus set="method"><f a=""><e path="Void"/></f></focus>
	<firstChild><t path="js.HtmlDom"/></firstChild>
	<disabled><e path="Bool"/></disabled>
	<dir><c path="String"/></dir>
	<defaultValue><c path="String"/></defaultValue>
	<cloneNode set="method"><f a="deep">
	<e path="Bool"/>
	<t path="js.HtmlDom"/>
</f></cloneNode>
	<clientWidth set="null"><c path="Int"/></clientWidth>
	<clientHeight set="null"><c path="Int"/></clientHeight>
	<click set="method"><f a=""><e path="Void"/></f></click>
	<className><c path="String"/></className>
	<childNodes><c path="js.HtmlCollection"><t path="js.HtmlDom"/></c></childNodes>
	<blur set="method"><f a=""><e path="Void"/></f></blur>
	<appendChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></appendChild>
</a></typedef>
	<typedef path="js.Radio" params="" file="/usr/share/haxe/std/js/Dom.hx" module="js.Dom"><a>
	<value><c path="String"/></value>
	<type><c path="String"/></type>
	<title><c path="String"/></title>
	<style><t path="js.Style"/></style>
	<size><c path="Int"/></size>
	<setAttribute set="method"><f a="attr:val">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></setAttribute>
	<select set="method"><f a=""><e path="Void"/></f></select>
	<scrollWidth set="null"><c path="Int"/></scrollWidth>
	<scrollTop><c path="Int"/></scrollTop>
	<scrollLeft><c path="Int"/></scrollLeft>
	<scrollHeight set="null"><c path="Int"/></scrollHeight>
	<replaceChild set="method"><f a="child:oldChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></replaceChild>
	<removeChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
</f></removeChild>
	<previousSibling><t path="js.HtmlDom"/></previousSibling>
	<parentNode><t path="js.HtmlDom"/></parentNode>
	<onselect><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onselect>
	<onscroll><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onscroll>
	<onresize><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onresize>
	<onmouseup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseup>
	<onmouseover><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseover>
	<onmouseout><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseout>
	<onmousemove><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousemove>
	<onmousedown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousedown>
	<onkeyup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeyup>
	<onkeypress><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeypress>
	<onkeydown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeydown>
	<onfocus><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onfocus>
	<ondblclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></ondblclick>
	<onclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onclick>
	<onchange><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onchange>
	<onblur><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onblur>
	<offsetWidth><c path="Int"/></offsetWidth>
	<offsetTop><c path="Int"/></offsetTop>
	<offsetParent><t path="js.HtmlDom"/></offsetParent>
	<offsetLeft><c path="Int"/></offsetLeft>
	<offsetHeight><c path="Int"/></offsetHeight>
	<nodeValue><c path="String"/></nodeValue>
	<nodeType><c path="Int"/></nodeType>
	<nodeName><c path="String"/></nodeName>
	<nextSibling><t path="js.HtmlDom"/></nextSibling>
	<name><c path="String"/></name>
	<lastChild><t path="js.HtmlDom"/></lastChild>
	<lang><c path="String"/></lang>
	<insertBefore set="method"><f a="newChild:refChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></insertBefore>
	<innerHTML><c path="String"/></innerHTML>
	<id><c path="String"/></id>
	<hasChildNodes set="method"><f a=""><e path="Bool"/></f></hasChildNodes>
	<getElementsByTagName set="method"><f a="tag">
	<c path="String"/>
	<c path="js.HtmlCollection"><t path="js.HtmlDom"/></c>
</f></getElementsByTagName>
	<getAttribute set="method"><f a="attr">
	<c path="String"/>
	<c path="String"/>
</f></getAttribute>
	<form><t path="js.Form"/></form>
	<focus set="method"><f a=""><e path="Void"/></f></focus>
	<firstChild><t path="js.HtmlDom"/></firstChild>
	<disabled><e path="Bool"/></disabled>
	<dir><c path="String"/></dir>
	<defaultChecked><e path="Bool"/></defaultChecked>
	<cloneNode set="method"><f a="deep">
	<e path="Bool"/>
	<t path="js.HtmlDom"/>
</f></cloneNode>
	<clientWidth set="null"><c path="Int"/></clientWidth>
	<clientHeight set="null"><c path="Int"/></clientHeight>
	<click set="method"><f a=""><e path="Void"/></f></click>
	<className><c path="String"/></className>
	<childNodes><c path="js.HtmlCollection"><t path="js.HtmlDom"/></c></childNodes>
	<checked><e path="Bool"/></checked>
	<blur set="method"><f a=""><e path="Void"/></f></blur>
	<appendChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></appendChild>
</a></typedef>
	<typedef path="js.Reset" params="" file="/usr/share/haxe/std/js/Dom.hx" module="js.Dom"><a>
	<value><c path="String"/></value>
	<type><c path="String"/></type>
	<title><c path="String"/></title>
	<style><t path="js.Style"/></style>
	<setAttribute set="method"><f a="attr:val">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></setAttribute>
	<select set="method"><f a=""><e path="Void"/></f></select>
	<scrollWidth set="null"><c path="Int"/></scrollWidth>
	<scrollTop><c path="Int"/></scrollTop>
	<scrollLeft><c path="Int"/></scrollLeft>
	<scrollHeight set="null"><c path="Int"/></scrollHeight>
	<replaceChild set="method"><f a="child:oldChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></replaceChild>
	<removeChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
</f></removeChild>
	<previousSibling><t path="js.HtmlDom"/></previousSibling>
	<parentNode><t path="js.HtmlDom"/></parentNode>
	<onselect><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onselect>
	<onscroll><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onscroll>
	<onresize><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onresize>
	<onmouseup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseup>
	<onmouseover><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseover>
	<onmouseout><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseout>
	<onmousemove><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousemove>
	<onmousedown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousedown>
	<onkeyup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeyup>
	<onkeypress><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeypress>
	<onkeydown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeydown>
	<onfocus><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onfocus>
	<ondblclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></ondblclick>
	<onclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onclick>
	<onchange><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onchange>
	<onblur><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onblur>
	<offsetWidth><c path="Int"/></offsetWidth>
	<offsetTop><c path="Int"/></offsetTop>
	<offsetParent><t path="js.HtmlDom"/></offsetParent>
	<offsetLeft><c path="Int"/></offsetLeft>
	<offsetHeight><c path="Int"/></offsetHeight>
	<nodeValue><c path="String"/></nodeValue>
	<nodeType><c path="Int"/></nodeType>
	<nodeName><c path="String"/></nodeName>
	<nextSibling><t path="js.HtmlDom"/></nextSibling>
	<name><c path="String"/></name>
	<lastChild><t path="js.HtmlDom"/></lastChild>
	<lang><c path="String"/></lang>
	<insertBefore set="method"><f a="newChild:refChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></insertBefore>
	<innerHTML><c path="String"/></innerHTML>
	<id><c path="String"/></id>
	<hasChildNodes set="method"><f a=""><e path="Bool"/></f></hasChildNodes>
	<getElementsByTagName set="method"><f a="tag">
	<c path="String"/>
	<c path="js.HtmlCollection"><t path="js.HtmlDom"/></c>
</f></getElementsByTagName>
	<getAttribute set="method"><f a="attr">
	<c path="String"/>
	<c path="String"/>
</f></getAttribute>
	<form><t path="js.Form"/></form>
	<focus set="method"><f a=""><e path="Void"/></f></focus>
	<firstChild><t path="js.HtmlDom"/></firstChild>
	<disabled><e path="Bool"/></disabled>
	<dir><c path="String"/></dir>
	<cloneNode set="method"><f a="deep">
	<e path="Bool"/>
	<t path="js.HtmlDom"/>
</f></cloneNode>
	<clientWidth set="null"><c path="Int"/></clientWidth>
	<clientHeight set="null"><c path="Int"/></clientHeight>
	<click set="method"><f a=""><e path="Void"/></f></click>
	<className><c path="String"/></className>
	<childNodes><c path="js.HtmlCollection"><t path="js.HtmlDom"/></c></childNodes>
	<blur set="method"><f a=""><e path="Void"/></f></blur>
	<appendChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></appendChild>
</a></typedef>
	<typedef path="js.Screen" params="" file="/usr/share/haxe/std/js/Dom.hx" module="js.Dom"><a>
	<width><c path="Int"/></width>
	<height><c path="Int"/></height>
	<colorDepth><c path="Int"/></colorDepth>
	<availWidth><c path="Int"/></availWidth>
	<availHeight><c path="Int"/></availHeight>
</a></typedef>
	<typedef path="js.Select" params="" file="/usr/share/haxe/std/js/Dom.hx" module="js.Dom"><a>
	<value><c path="String"/></value>
	<type><c path="String"/></type>
	<title><c path="String"/></title>
	<style><t path="js.Style"/></style>
	<size><c path="Int"/></size>
	<setAttribute set="method"><f a="attr:val">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></setAttribute>
	<selectedIndex><c path="Int"/></selectedIndex>
	<select set="method"><f a=""><e path="Void"/></f></select>
	<scrollWidth set="null"><c path="Int"/></scrollWidth>
	<scrollTop><c path="Int"/></scrollTop>
	<scrollLeft><c path="Int"/></scrollLeft>
	<scrollHeight set="null"><c path="Int"/></scrollHeight>
	<replaceChild set="method"><f a="child:oldChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></replaceChild>
	<removeChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
</f></removeChild>
	<remove set="method"><f a="o">
	<c path="Int"/>
	<e path="Void"/>
</f></remove>
	<previousSibling><t path="js.HtmlDom"/></previousSibling>
	<parentNode><t path="js.HtmlDom"/></parentNode>
	<options><c path="js.HtmlCollection"><t path="js.Option"/></c></options>
	<onselect><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onselect>
	<onscroll><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onscroll>
	<onresize><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onresize>
	<onmouseup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseup>
	<onmouseover><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseover>
	<onmouseout><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseout>
	<onmousemove><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousemove>
	<onmousedown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousedown>
	<onkeyup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeyup>
	<onkeypress><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeypress>
	<onkeydown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeydown>
	<onfocus><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onfocus>
	<ondblclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></ondblclick>
	<onclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onclick>
	<onchange><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onchange>
	<onblur><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onblur>
	<offsetWidth><c path="Int"/></offsetWidth>
	<offsetTop><c path="Int"/></offsetTop>
	<offsetParent><t path="js.HtmlDom"/></offsetParent>
	<offsetLeft><c path="Int"/></offsetLeft>
	<offsetHeight><c path="Int"/></offsetHeight>
	<nodeValue><c path="String"/></nodeValue>
	<nodeType><c path="Int"/></nodeType>
	<nodeName><c path="String"/></nodeName>
	<nextSibling><t path="js.HtmlDom"/></nextSibling>
	<name><c path="String"/></name>
	<multiple><e path="Bool"/></multiple>
	<length><c path="Int"/></length>
	<lastChild><t path="js.HtmlDom"/></lastChild>
	<lang><c path="String"/></lang>
	<insertBefore set="method"><f a="newChild:refChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></insertBefore>
	<innerHTML><c path="String"/></innerHTML>
	<id><c path="String"/></id>
	<hasChildNodes set="method"><f a=""><e path="Bool"/></f></hasChildNodes>
	<getElementsByTagName set="method"><f a="tag">
	<c path="String"/>
	<c path="js.HtmlCollection"><t path="js.HtmlDom"/></c>
</f></getElementsByTagName>
	<getAttribute set="method"><f a="attr">
	<c path="String"/>
	<c path="String"/>
</f></getAttribute>
	<form><t path="js.Form"/></form>
	<focus set="method"><f a=""><e path="Void"/></f></focus>
	<firstChild><t path="js.HtmlDom"/></firstChild>
	<disabled><e path="Bool"/></disabled>
	<dir><c path="String"/></dir>
	<cloneNode set="method"><f a="deep">
	<e path="Bool"/>
	<t path="js.HtmlDom"/>
</f></cloneNode>
	<clientWidth set="null"><c path="Int"/></clientWidth>
	<clientHeight set="null"><c path="Int"/></clientHeight>
	<click set="method"><f a=""><e path="Void"/></f></click>
	<className><c path="String"/></className>
	<childNodes><c path="js.HtmlCollection"><t path="js.HtmlDom"/></c></childNodes>
	<blur set="method"><f a=""><e path="Void"/></f></blur>
	<appendChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></appendChild>
</a></typedef>
	<typedef path="js.Style" params="" file="/usr/share/haxe/std/js/Dom.hx" module="js.Dom"><a>
	<zoom><d/></zoom>
	<zIndex><c path="Int"/></zIndex>
	<writingMode><d/></writingMode>
	<wordWrap><d/></wordWrap>
	<wordSpacing><d/></wordSpacing>
	<wordBreak><d/></wordBreak>
	<width><c path="String"/></width>
	<whiteSpace><d/></whiteSpace>
	<visibility><d/></visibility>
	<verticalAlign><d/></verticalAlign>
	<unicodeBidi><d/></unicodeBidi>
	<top><c path="String"/></top>
	<textUnderlinePosition><d/></textUnderlinePosition>
	<textTransform><d/></textTransform>
	<textShadow><d/></textShadow>
	<textOverflow><d/></textOverflow>
	<textKashidaSpace><d/></textKashidaSpace>
	<textJustifyTrim><d/></textJustifyTrim>
	<textJustify><d/></textJustify>
	<textIndent><d/></textIndent>
	<textDecorationLineUnderline><d/></textDecorationLineUnderline>
	<textDecorationLineThrough><d/></textDecorationLineThrough>
	<textDecorationLineOverline><d/></textDecorationLineOverline>
	<textDecorationLineNone><d/></textDecorationLineNone>
	<textDecorationBlink><d/></textDecorationBlink>
	<textDecoration><d/></textDecoration>
	<textAutospace><d/></textAutospace>
	<textAlignLast><d/></textAlignLast>
	<textAlign><d/></textAlign>
	<styleFloat><d/></styleFloat>
	<rubyPosition><d/></rubyPosition>
	<rubyOverhang><d/></rubyOverhang>
	<rubyAlign><d/></rubyAlign>
	<right><c path="String"/></right>
	<quotes><d/></quotes>
	<position><d/></position>
	<paddingTop><d/></paddingTop>
	<paddingRight><d/></paddingRight>
	<paddingLeft><d/></paddingLeft>
	<paddingBottom><d/></paddingBottom>
	<padding><d/></padding>
	<overflowY><d/></overflowY>
	<overflowX><d/></overflowX>
	<overflow><d/></overflow>
	<outlineWidth><d/></outlineWidth>
	<outlineStyle><d/></outlineStyle>
	<outlineColor><d/></outlineColor>
	<outline><d/></outline>
	<minWidth><d/></minWidth>
	<minHeight><d/></minHeight>
	<maxWidth><d/></maxWidth>
	<maxHeight><d/></maxHeight>
	<marks><d/></marks>
	<markerOffset><d/></markerOffset>
	<marginTop><d/></marginTop>
	<marginRight><d/></marginRight>
	<marginLeft><d/></marginLeft>
	<marginBottom><d/></marginBottom>
	<margin><d/></margin>
	<listStyleType><c path="String"/></listStyleType>
	<listStylePosition><d/></listStylePosition>
	<listStyleImage><d/></listStyleImage>
	<listStyle><d/></listStyle>
	<lineHeight><d/></lineHeight>
	<lineBreak><d/></lineBreak>
	<letterSpacing><d/></letterSpacing>
	<left><c path="String"/></left>
	<height><c path="String"/></height>
	<fontWeight><d/></fontWeight>
	<fontVariant><d/></fontVariant>
	<fontStyle><d/></fontStyle>
	<fontStretch><d/></fontStretch>
	<fontSizeAdjust><d/></fontSizeAdjust>
	<fontSize><d/></fontSize>
	<fontFamily><d/></fontFamily>
	<font><d/></font>
	<display><d/></display>
	<direction><d/></direction>
	<cursor><d/></cursor>
	<cssText><d/></cssText>
	<cssFloat><d/></cssFloat>
	<counterReset><d/></counterReset>
	<counterIncrement><d/></counterIncrement>
	<content><d/></content>
	<color><d/></color>
	<clipTop><d/></clipTop>
	<clipRight><d/></clipRight>
	<clipLeft><d/></clipLeft>
	<clipBottom><d/></clipBottom>
	<clip><d/></clip>
	<clear><c path="String"/></clear>
	<bottom><c path="String"/></bottom>
	<borderWidth><d/></borderWidth>
	<borderTopWidth><d/></borderTopWidth>
	<borderTopStyle><d/></borderTopStyle>
	<borderTopColor><d/></borderTopColor>
	<borderTop><d/></borderTop>
	<borderStyle><c path="String"/></borderStyle>
	<borderRightWidth><d/></borderRightWidth>
	<borderRightStyle><d/></borderRightStyle>
	<borderRightColor><d/></borderRightColor>
	<borderRight><d/></borderRight>
	<borderLeftWidth><d/></borderLeftWidth>
	<borderLeftStyle><d/></borderLeftStyle>
	<borderLeftColor><d/></borderLeftColor>
	<borderLeft><d/></borderLeft>
	<borderColor><d/></borderColor>
	<borderBottomWidth><d/></borderBottomWidth>
	<borderBottomStyle><d/></borderBottomStyle>
	<borderBottomColor><d/></borderBottomColor>
	<borderBottom><d/></borderBottom>
	<border><d/></border>
	<backgroundRepeat><d/></backgroundRepeat>
	<backgroundPosition><d/></backgroundPosition>
	<backgroundImage><d/></backgroundImage>
	<backgroundColor><d/></backgroundColor>
	<backgroundAttachment><d/></backgroundAttachment>
	<background><d/></background>
</a></typedef>
	<typedef path="js.StyleSheet" params="" file="/usr/share/haxe/std/js/Dom.hx" module="js.Dom"><a>
	<type><c path="String"/></type>
	<title><c path="String"/></title>
	<href><c path="String"/></href>
	<disabled><e path="Bool"/></disabled>
</a></typedef>
	<typedef path="js.Submit" params="" file="/usr/share/haxe/std/js/Dom.hx" module="js.Dom"><a>
	<value><c path="String"/></value>
	<type><c path="String"/></type>
	<title><c path="String"/></title>
	<style><t path="js.Style"/></style>
	<setAttribute set="method"><f a="attr:val">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></setAttribute>
	<select set="method"><f a=""><e path="Void"/></f></select>
	<scrollWidth set="null"><c path="Int"/></scrollWidth>
	<scrollTop><c path="Int"/></scrollTop>
	<scrollLeft><c path="Int"/></scrollLeft>
	<scrollHeight set="null"><c path="Int"/></scrollHeight>
	<replaceChild set="method"><f a="child:oldChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></replaceChild>
	<removeChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
</f></removeChild>
	<previousSibling><t path="js.HtmlDom"/></previousSibling>
	<parentNode><t path="js.HtmlDom"/></parentNode>
	<onselectstart><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onselectstart>
	<onselect><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onselect>
	<onscroll><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onscroll>
	<onresize><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onresize>
	<onmouseup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseup>
	<onmouseover><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseover>
	<onmouseout><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseout>
	<onmousemove><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousemove>
	<onmousedown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousedown>
	<onkeyup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeyup>
	<onkeypress><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeypress>
	<onkeydown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeydown>
	<onfocus><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onfocus>
	<ondblclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></ondblclick>
	<onclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onclick>
	<onchange><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onchange>
	<onblur><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onblur>
	<offsetWidth><c path="Int"/></offsetWidth>
	<offsetTop><c path="Int"/></offsetTop>
	<offsetParent><t path="js.HtmlDom"/></offsetParent>
	<offsetLeft><c path="Int"/></offsetLeft>
	<offsetHeight><c path="Int"/></offsetHeight>
	<nodeValue><c path="String"/></nodeValue>
	<nodeType><c path="Int"/></nodeType>
	<nodeName><c path="String"/></nodeName>
	<nextSibling><t path="js.HtmlDom"/></nextSibling>
	<name><c path="String"/></name>
	<lastChild><t path="js.HtmlDom"/></lastChild>
	<lang><c path="String"/></lang>
	<insertBefore set="method"><f a="newChild:refChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></insertBefore>
	<innerHTML><c path="String"/></innerHTML>
	<id><c path="String"/></id>
	<hasChildNodes set="method"><f a=""><e path="Bool"/></f></hasChildNodes>
	<getElementsByTagName set="method"><f a="tag">
	<c path="String"/>
	<c path="js.HtmlCollection"><t path="js.HtmlDom"/></c>
</f></getElementsByTagName>
	<getAttribute set="method"><f a="attr">
	<c path="String"/>
	<c path="String"/>
</f></getAttribute>
	<form><t path="js.Form"/></form>
	<focus set="method"><f a=""><e path="Void"/></f></focus>
	<firstChild><t path="js.HtmlDom"/></firstChild>
	<disabled><e path="Bool"/></disabled>
	<dir><c path="String"/></dir>
	<cloneNode set="method"><f a="deep">
	<e path="Bool"/>
	<t path="js.HtmlDom"/>
</f></cloneNode>
	<clientWidth set="null"><c path="Int"/></clientWidth>
	<clientHeight set="null"><c path="Int"/></clientHeight>
	<click set="method"><f a=""><e path="Void"/></f></click>
	<className><c path="String"/></className>
	<childNodes><c path="js.HtmlCollection"><t path="js.HtmlDom"/></c></childNodes>
	<blur set="method"><f a=""><e path="Void"/></f></blur>
	<appendChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></appendChild>
</a></typedef>
	<typedef path="js.Text" params="" file="/usr/share/haxe/std/js/Dom.hx" module="js.Dom"><a>
	<value><c path="String"/></value>
	<type><c path="String"/></type>
	<title><c path="String"/></title>
	<style><t path="js.Style"/></style>
	<size><c path="Int"/></size>
	<setAttribute set="method"><f a="attr:val">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></setAttribute>
	<select set="method"><f a=""><e path="Void"/></f></select>
	<scrollWidth set="null"><c path="Int"/></scrollWidth>
	<scrollTop><c path="Int"/></scrollTop>
	<scrollLeft><c path="Int"/></scrollLeft>
	<scrollHeight set="null"><c path="Int"/></scrollHeight>
	<replaceChild set="method"><f a="child:oldChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></replaceChild>
	<removeChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
</f></removeChild>
	<readOnly><e path="Bool"/></readOnly>
	<previousSibling><t path="js.HtmlDom"/></previousSibling>
	<parentNode><t path="js.HtmlDom"/></parentNode>
	<onselect><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onselect>
	<onscroll><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onscroll>
	<onresize><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onresize>
	<onmouseup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseup>
	<onmouseover><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseover>
	<onmouseout><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseout>
	<onmousemove><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousemove>
	<onmousedown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousedown>
	<onkeyup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeyup>
	<onkeypress><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeypress>
	<onkeydown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeydown>
	<onfocus><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onfocus>
	<ondblclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></ondblclick>
	<onclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onclick>
	<onchange><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onchange>
	<onblur><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onblur>
	<offsetWidth><c path="Int"/></offsetWidth>
	<offsetTop><c path="Int"/></offsetTop>
	<offsetParent><t path="js.HtmlDom"/></offsetParent>
	<offsetLeft><c path="Int"/></offsetLeft>
	<offsetHeight><c path="Int"/></offsetHeight>
	<nodeValue><c path="String"/></nodeValue>
	<nodeType><c path="Int"/></nodeType>
	<nodeName><c path="String"/></nodeName>
	<nextSibling><t path="js.HtmlDom"/></nextSibling>
	<name><c path="String"/></name>
	<maxLength><c path="Int"/></maxLength>
	<lastChild><t path="js.HtmlDom"/></lastChild>
	<lang><c path="String"/></lang>
	<insertBefore set="method"><f a="newChild:refChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></insertBefore>
	<innerHTML><c path="String"/></innerHTML>
	<id><c path="String"/></id>
	<hasChildNodes set="method"><f a=""><e path="Bool"/></f></hasChildNodes>
	<getElementsByTagName set="method"><f a="tag">
	<c path="String"/>
	<c path="js.HtmlCollection"><t path="js.HtmlDom"/></c>
</f></getElementsByTagName>
	<getAttribute set="method"><f a="attr">
	<c path="String"/>
	<c path="String"/>
</f></getAttribute>
	<form><t path="js.Form"/></form>
	<focus set="method"><f a=""><e path="Void"/></f></focus>
	<firstChild><t path="js.HtmlDom"/></firstChild>
	<disabled><e path="Bool"/></disabled>
	<dir><c path="String"/></dir>
	<defaultValue><c path="String"/></defaultValue>
	<cloneNode set="method"><f a="deep">
	<e path="Bool"/>
	<t path="js.HtmlDom"/>
</f></cloneNode>
	<clientWidth set="null"><c path="Int"/></clientWidth>
	<clientHeight set="null"><c path="Int"/></clientHeight>
	<click set="method"><f a=""><e path="Void"/></f></click>
	<className><c path="String"/></className>
	<childNodes><c path="js.HtmlCollection"><t path="js.HtmlDom"/></c></childNodes>
	<blur set="method"><f a=""><e path="Void"/></f></blur>
	<appendChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></appendChild>
</a></typedef>
	<typedef path="js.Textarea" params="" file="/usr/share/haxe/std/js/Dom.hx" module="js.Dom"><a>
	<value><c path="String"/></value>
	<type><c path="String"/></type>
	<title><c path="String"/></title>
	<style><t path="js.Style"/></style>
	<setAttribute set="method"><f a="attr:val">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></setAttribute>
	<select set="method"><f a=""><e path="Void"/></f></select>
	<scrollWidth set="null"><c path="Int"/></scrollWidth>
	<scrollTop><c path="Int"/></scrollTop>
	<scrollLeft><c path="Int"/></scrollLeft>
	<scrollHeight set="null"><c path="Int"/></scrollHeight>
	<rows><c path="Int"/></rows>
	<replaceChild set="method"><f a="child:oldChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></replaceChild>
	<removeChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
</f></removeChild>
	<readOnly><e path="Bool"/></readOnly>
	<previousSibling><t path="js.HtmlDom"/></previousSibling>
	<parentNode><t path="js.HtmlDom"/></parentNode>
	<onselect><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onselect>
	<onscroll><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onscroll>
	<onresize><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onresize>
	<onmouseup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseup>
	<onmouseover><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseover>
	<onmouseout><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseout>
	<onmousemove><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousemove>
	<onmousedown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousedown>
	<onkeyup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeyup>
	<onkeypress><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeypress>
	<onkeydown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeydown>
	<onfocus><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onfocus>
	<ondblclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></ondblclick>
	<onclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onclick>
	<onchange><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onchange>
	<onblur><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onblur>
	<offsetWidth><c path="Int"/></offsetWidth>
	<offsetTop><c path="Int"/></offsetTop>
	<offsetParent><t path="js.HtmlDom"/></offsetParent>
	<offsetLeft><c path="Int"/></offsetLeft>
	<offsetHeight><c path="Int"/></offsetHeight>
	<nodeValue><c path="String"/></nodeValue>
	<nodeType><c path="Int"/></nodeType>
	<nodeName><c path="String"/></nodeName>
	<nextSibling><t path="js.HtmlDom"/></nextSibling>
	<name><c path="String"/></name>
	<lastChild><t path="js.HtmlDom"/></lastChild>
	<lang><c path="String"/></lang>
	<insertBefore set="method"><f a="newChild:refChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></insertBefore>
	<innerHTML><c path="String"/></innerHTML>
	<id><c path="String"/></id>
	<hasChildNodes set="method"><f a=""><e path="Bool"/></f></hasChildNodes>
	<getElementsByTagName set="method"><f a="tag">
	<c path="String"/>
	<c path="js.HtmlCollection"><t path="js.HtmlDom"/></c>
</f></getElementsByTagName>
	<getAttribute set="method"><f a="attr">
	<c path="String"/>
	<c path="String"/>
</f></getAttribute>
	<form><t path="js.Form"/></form>
	<focus set="method"><f a=""><e path="Void"/></f></focus>
	<firstChild><t path="js.HtmlDom"/></firstChild>
	<disabled><e path="Bool"/></disabled>
	<dir><c path="String"/></dir>
	<defaultValue><c path="String"/></defaultValue>
	<cols><c path="Int"/></cols>
	<cloneNode set="method"><f a="deep">
	<e path="Bool"/>
	<t path="js.HtmlDom"/>
</f></cloneNode>
	<clientWidth set="null"><c path="Int"/></clientWidth>
	<clientHeight set="null"><c path="Int"/></clientHeight>
	<click set="method"><f a=""><e path="Void"/></f></click>
	<className><c path="String"/></className>
	<childNodes><c path="js.HtmlCollection"><t path="js.HtmlDom"/></c></childNodes>
	<blur set="method"><f a=""><e path="Void"/></f></blur>
	<appendChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></appendChild>
</a></typedef>
	<typedef path="js.Window" params="" file="/usr/share/haxe/std/js/Dom.hx" module="js.Dom"><a>
	<top><t path="js.Window"/></top>
	<status><c path="String"/></status>
	<self><t path="js.Window"/></self>
	<scrollTo set="method"><f a="x:y">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></scrollTo>
	<scrollBy set="method"><f a="dx:dy">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></scrollBy>
	<screen><t path="js.Screen"/></screen>
	<prompt set="method"><f a="msg:?def">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></prompt>
	<print set="method"><f a=""><e path="Void"/></f></print>
	<parent><t path="js.Window"/></parent>
	<outerWidth><c path="Int"/></outerWidth>
	<outerHeight><c path="Int"/></outerHeight>
	<opener><t path="js.Window"/></opener>
	<open set="method"><f a="url:?name:?features">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<t path="js.Window"/>
</f></open>
	<onunload><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onunload>
	<onscroll><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onscroll>
	<onresize><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onresize>
	<onload><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onload>
	<onerror><f a="::">
	<c path="String"/>
	<c path="String"/>
	<c path="Int"/>
	<e path="Bool"/>
</f></onerror>
	<navigator><t path="js.Navigator"/></navigator>
	<name><c path="String"/></name>
	<moveTo set="method"><f a="x:y">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></moveTo>
	<moveBy set="method"><f a="dx:dy">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></moveBy>
	<location><t path="js.Location"/></location>
	<length><c path="Int"/></length>
	<innerWidth><c path="Int"/></innerWidth>
	<innerHeight><c path="Int"/></innerHeight>
	<history><t path="js.History"/></history>
	<frames><c path="js.HtmlCollection"><t path="js.Frame"/></c></frames>
	<focus set="method"><f a=""><e path="Void"/></f></focus>
	<document><t path="js.Document"/></document>
	<defaultStatus><c path="String"/></defaultStatus>
	<confirm set="method"><f a="msg">
	<c path="String"/>
	<e path="Bool"/>
</f></confirm>
	<closed><e path="Bool"/></closed>
	<close set="method"><f a=""><e path="Void"/></f></close>
	<blur set="method"><f a=""><e path="Void"/></f></blur>
	<alert set="method"><f a="msg">
	<c path="String"/>
	<e path="Void"/>
</f></alert>
</a></typedef>
	<typedef path="js.JqEvent" params="" file="/usr/share/haxe/std/js/JQuery.hx" module="js.JQuery"><a>
	<which><c path="Int"/></which>
	<wheelDelta><c path="Int"/></wheelDelta>
	<type><c path="String"/></type>
	<timeStamp><c path="Int"/></timeStamp>
	<target><t path="js.HtmlDom"/></target>
	<stopPropagation set="method"><f a=""><e path="Void"/></f></stopPropagation>
	<stopImmediatePropagation set="method"><f a=""><e path="Void"/></f></stopImmediatePropagation>
	<shiftKey><e path="Bool"/></shiftKey>
	<relatedTarget><t path="js.HtmlDom"/></relatedTarget>
	<preventDefault set="method"><f a=""><e path="Void"/></f></preventDefault>
	<pageY><c path="Int"/></pageY>
	<pageX><c path="Int"/></pageX>
	<metaKey><e path="Bool"/></metaKey>
	<keyCode><c path="Int"/></keyCode>
	<isPropationStopped set="method"><f a=""><e path="Bool"/></f></isPropationStopped>
	<isImmediatePropagationStopped set="method"><f a=""><e path="Bool"/></f></isImmediatePropagationStopped>
	<isDefaultPrevented set="method"><f a=""><e path="Bool"/></f></isDefaultPrevented>
	<currentTarget><t path="js.HtmlDom"/></currentTarget>
	<ctrlKey><e path="Bool"/></ctrlKey>
	<charCode><c path="Int"/></charCode>
	<altKey><e path="Bool"/></altKey>
</a></typedef>
	<class path="js.JQuery" params="" file="/usr/share/haxe/std/js/JQuery.hx" extern="1">
		<cur public="1" get="getCurrent" set="null" static="1">
			<c path="js.JQuery"/>
			<haxe_doc>
		Return the current JQuery element (in a callback), similar to $(this) in JS.
	</haxe_doc>
		</cur>
		<fx public="1" set="null" static="1"><a>
	<off><e path="Bool"/></off>
	<interval><c path="Int"/></interval>
</a></fx>
		<browser public="1" set="null" static="1"><a>
	<webkit><e path="Bool"/></webkit>
	<version><c path="String"/></version>
	<opera><e path="Bool"/></opera>
	<msie><e path="Bool"/></msie>
	<mozilla><e path="Bool"/></mozilla>
</a></browser>
		<contains public="1" set="method" static="1"><f a="parent:child">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Bool"/>
</f></contains>
		<noConflict public="1" set="method" static="1"><f a="?removeAll">
	<e path="Bool"/>
	<e path="Void"/>
</f></noConflict>
		<parseJSON public="1" set="method" static="1"><f a="json">
	<c path="String"/>
	<d/>
</f></parseJSON>
		<globalEval public="1" set="method" static="1"><f a="js">
	<c path="String"/>
	<e path="Void"/>
</f></globalEval>
		<getCurrent get="inline" set="null" line="336" static="1"><f a=""><c path="js.JQuery"/></f></getCurrent>
		<context public="1" set="null"><t path="js.HtmlDom"/></context>
		<length public="1" set="null"><c path="Int"/></length>
		<addClass public="1" set="method"><f a="className">
	<c path="String"/>
	<c path="js.JQuery"/>
</f></addClass>
		<removeClass public="1" set="method"><f a="?className">
	<c path="String"/>
	<c path="js.JQuery"/>
</f></removeClass>
		<hasClass public="1" set="method"><f a="className">
	<c path="String"/>
	<e path="Bool"/>
</f></hasClass>
		<toggleClass public="1" set="method"><f a="className:?addRemove">
	<c path="String"/>
	<e path="Bool"/>
	<c path="js.JQuery"/>
</f></toggleClass>
		<attr public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="String"/>
</f></attr>
		<removeAttr public="1" set="method"><f a="attr">
	<c path="String"/>
	<c path="js.JQuery"/>
</f></removeAttr>
		<css public="1" set="method"><f a="prop">
	<c path="String"/>
	<c path="String"/>
</f></css>
		<html public="1" set="method"><f a=""><c path="String"/></f></html>
		<val public="1" set="method"><f a=""><c path="String"/></f></val>
		<text public="1" set="method"><f a=""><c path="String"/></f></text>
		<width public="1" set="method"><f a=""><c path="Int"/></f></width>
		<height public="1" set="method"><f a=""><c path="Int"/></f></height>
		<innerWidth public="1" set="method"><f a=""><c path="Int"/></f></innerWidth>
		<innerHeight public="1" set="method"><f a=""><c path="Int"/></f></innerHeight>
		<outerWidth public="1" set="method"><f a="?includeMargin">
	<e path="Bool"/>
	<c path="Int"/>
</f></outerWidth>
		<outerHeight public="1" set="method"><f a="?includeMargin">
	<e path="Bool"/>
	<c path="Int"/>
</f></outerHeight>
		<scrollLeft public="1" set="method"><f a=""><c path="Int"/></f></scrollLeft>
		<scrollTop public="1" set="method"><f a=""><c path="Int"/></f></scrollTop>
		<offset public="1" set="method"><f a=""><a>
	<top><c path="Int"/></top>
	<left><c path="Int"/></left>
</a></f></offset>
		<offsetParent public="1" set="method"><f a=""><c path="js.JQuery"/></f></offsetParent>
		<position public="1" set="method"><f a=""><a>
	<top><c path="Int"/></top>
	<left><c path="Int"/></left>
</a></f></position>
		<add public="1" set="method"><f a="selector:?context">
	<c path="String"/>
	<c path="js.JQuery"/>
	<c path="js.JQuery"/>
</f></add>
		<andSelf public="1" set="method"><f a=""><c path="js.JQuery"/></f></andSelf>
		<children public="1" set="method"><f a="?selector">
	<c path="String"/>
	<c path="js.JQuery"/>
</f></children>
		<clone public="1" set="method"><f a="?withDataAndEvents">
	<e path="Bool"/>
	<c path="js.JQuery"/>
</f></clone>
		<closest public="1" set="method"><f a="selector:?context">
	<c path="String"/>
	<c path="js.JQuery"/>
	<c path="js.JQuery"/>
</f></closest>
		<contents public="1" set="method"><f a=""><c path="js.JQuery"/></f></contents>
		<each public="1" set="method"><f a="f">
	<f a=""><e path="Void"/></f>
	<c path="js.JQuery"/>
</f></each>
		<end public="1" set="method"><f a=""><c path="js.JQuery"/></f></end>
		<eq public="1" set="method"><f a="index">
	<c path="Int"/>
	<c path="js.JQuery"/>
</f></eq>
		<filter public="1" set="method"><f a="selector">
	<c path="String"/>
	<c path="js.JQuery"/>
</f></filter>
		<find public="1" set="method"><f a="selector">
	<c path="String"/>
	<c path="js.JQuery"/>
</f></find>
		<first public="1" set="method"><f a=""><c path="js.JQuery"/></f></first>
		<index public="1" set="method"><f a="?selector">
	<c path="String"/>
	<c path="Int"/>
</f></index>
		<last public="1" set="method"><f a="?selector">
	<c path="String"/>
	<c path="js.JQuery"/>
</f></last>
		<has public="1" set="method"><f a="selector">
	<c path="String"/>
	<c path="js.JQuery"/>
</f></has>
		<next public="1" set="method"><f a="?selector">
	<c path="String"/>
	<c path="js.JQuery"/>
</f></next>
		<nextAll public="1" set="method"><f a="?selector">
	<c path="String"/>
	<c path="js.JQuery"/>
</f></nextAll>
		<nextUntil public="1" set="method"><f a="?selector">
	<c path="String"/>
	<c path="js.JQuery"/>
</f></nextUntil>
		<parent public="1" set="method"><f a="?selector">
	<c path="String"/>
	<c path="js.JQuery"/>
</f></parent>
		<parents public="1" set="method"><f a="?selector">
	<c path="String"/>
	<c path="js.JQuery"/>
</f></parents>
		<parentsUntil public="1" set="method"><f a="?selector">
	<c path="String"/>
	<c path="js.JQuery"/>
</f></parentsUntil>
		<not public="1" set="method"><f a="selector">
	<c path="String"/>
	<c path="js.JQuery"/>
</f></not>
		<prev public="1" set="method"><f a="?selector">
	<c path="String"/>
	<c path="js.JQuery"/>
</f></prev>
		<prevAll public="1" set="method"><f a="?selector">
	<c path="String"/>
	<c path="js.JQuery"/>
</f></prevAll>
		<prevUntil public="1" set="method"><f a="?selector">
	<c path="String"/>
	<c path="js.JQuery"/>
</f></prevUntil>
		<pushStack public="1" set="method"><f a="elements">
	<c path="Array"><t path="js.HtmlDom"/></c>
	<c path="js.JQuery"/>
</f></pushStack>
		<siblings public="1" set="method"><f a="?selector">
	<c path="String"/>
	<c path="js.JQuery"/>
</f></siblings>
		<size public="1" set="method"><f a=""><c path="Int"/></f></size>
		<slice public="1" set="method"><f a="start:?end">
	<c path="Int"/>
	<c path="Int"/>
	<c path="js.JQuery"/>
</f></slice>
		<toArray public="1" set="method"><f a=""><c path="Array"><t path="js.HtmlDom"/></c></f></toArray>
		<before public="1" set="method"><f a="html">
	<c path="String"/>
	<c path="js.JQuery"/>
</f></before>
		<after public="1" set="method"><f a="html">
	<c path="String"/>
	<c path="js.JQuery"/>
</f></after>
		<append public="1" set="method"><f a="html">
	<c path="String"/>
	<c path="js.JQuery"/>
</f></append>
		<appendTo public="1" set="method"><f a="html">
	<c path="String"/>
	<c path="js.JQuery"/>
</f></appendTo>
		<detach public="1" set="method"><f a="?selector">
	<c path="String"/>
	<c path="js.JQuery"/>
</f></detach>
		<empty public="1" set="method"><f a=""><c path="js.JQuery"/></f></empty>
		<insertBefore public="1" set="method"><f a="html">
	<c path="String"/>
	<c path="js.JQuery"/>
</f></insertBefore>
		<insertAfter public="1" set="method"><f a="html">
	<c path="String"/>
	<c path="js.JQuery"/>
</f></insertAfter>
		<prepend public="1" set="method"><f a="html">
	<c path="String"/>
	<c path="js.JQuery"/>
</f></prepend>
		<prependTo public="1" set="method"><f a="html">
	<c path="String"/>
	<c path="js.JQuery"/>
</f></prependTo>
		<remove public="1" set="method"><f a="?selector">
	<c path="String"/>
	<c path="js.JQuery"/>
</f></remove>
		<replaceAll public="1" set="method"><f a="selector">
	<c path="String"/>
	<c path="js.JQuery"/>
</f></replaceAll>
		<replaceWith public="1" set="method"><f a="html">
	<c path="String"/>
	<c path="js.JQuery"/>
</f></replaceWith>
		<unwrap public="1" set="method"><f a=""><c path="js.JQuery"/></f></unwrap>
		<wrap public="1" set="method"><f a="html">
	<c path="String"/>
	<c path="js.JQuery"/>
</f></wrap>
		<wrapAll public="1" set="method"><f a="html">
	<c path="String"/>
	<c path="js.JQuery"/>
</f></wrapAll>
		<wrapInner public="1" set="method"><f a="html">
	<c path="String"/>
	<c path="js.JQuery"/>
</f></wrapInner>
		<animate public="1" set="method"><f a="properties:?duration:?callb">
	<a/>
	<c path="Int"/>
	<f a=""><e path="Void"/></f>
	<c path="js.JQuery"/>
</f></animate>
		<delay public="1" set="method"><f a="duration:?queueName">
	<c path="Int"/>
	<c path="String"/>
	<c path="js.JQuery"/>
</f></delay>
		<hide public="1" set="method"><f a="?duration:?call">
	<c path="Int"/>
	<f a=""><e path="Void"/></f>
	<c path="js.JQuery"/>
</f></hide>
		<fadeIn public="1" set="method"><f a="?duration:?call">
	<c path="Int"/>
	<f a=""><e path="Void"/></f>
	<c path="js.JQuery"/>
</f></fadeIn>
		<fadeOut public="1" set="method"><f a="?duration:?call">
	<c path="Int"/>
	<f a=""><e path="Void"/></f>
	<c path="js.JQuery"/>
</f></fadeOut>
		<fadeTo public="1" set="method"><f a="duration:opacity:?call">
	<c path="Int"/>
	<c path="Float"/>
	<f a=""><e path="Void"/></f>
	<c path="js.JQuery"/>
</f></fadeTo>
		<fadeToggle public="1" set="method"><f a="?duration:?call">
	<c path="Int"/>
	<f a=""><e path="Void"/></f>
	<c path="js.JQuery"/>
</f></fadeToggle>
		<show public="1" set="method"><f a="?duration:?call">
	<c path="Int"/>
	<f a=""><e path="Void"/></f>
	<c path="js.JQuery"/>
</f></show>
		<slideDown public="1" set="method"><f a="?duration:?call">
	<c path="Int"/>
	<f a=""><e path="Void"/></f>
	<c path="js.JQuery"/>
</f></slideDown>
		<slideToggle public="1" set="method"><f a="?duration:?call">
	<c path="Int"/>
	<f a=""><e path="Void"/></f>
	<c path="js.JQuery"/>
</f></slideToggle>
		<slideUp public="1" set="method"><f a="?duration:?call">
	<c path="Int"/>
	<f a=""><e path="Void"/></f>
	<c path="js.JQuery"/>
</f></slideUp>
		<stop public="1" set="method"><f a="?clearQueue:?jumpToEnd">
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="js.JQuery"/>
</f></stop>
		<toggle public="1" set="method"><f a="?duration:?call">
	<c path="Int"/>
	<f a=""><e path="Void"/></f>
	<c path="js.JQuery"/>
</f></toggle>
		<blur public="1" set="method"><f a="?callb">
	<f a="">
		<t path="js.JqEvent"/>
		<e path="Void"/>
	</f>
	<c path="js.JQuery"/>
</f></blur>
		<change public="1" set="method"><f a="?callb">
	<f a="">
		<t path="js.JqEvent"/>
		<e path="Void"/>
	</f>
	<c path="js.JQuery"/>
</f></change>
		<click public="1" set="method"><f a="?callb">
	<f a="">
		<t path="js.JqEvent"/>
		<e path="Void"/>
	</f>
	<c path="js.JQuery"/>
</f></click>
		<dblclick public="1" set="method"><f a="?callb">
	<f a="">
		<t path="js.JqEvent"/>
		<e path="Void"/>
	</f>
	<c path="js.JQuery"/>
</f></dblclick>
		<error public="1" set="method"><f a="?callb">
	<f a="">
		<t path="js.JqEvent"/>
		<e path="Void"/>
	</f>
	<c path="js.JQuery"/>
</f></error>
		<focus public="1" set="method"><f a="?callb">
	<f a="">
		<t path="js.JqEvent"/>
		<e path="Void"/>
	</f>
	<c path="js.JQuery"/>
</f></focus>
		<focusin public="1" set="method"><f a="?callb">
	<f a="">
		<t path="js.JqEvent"/>
		<e path="Void"/>
	</f>
	<c path="js.JQuery"/>
</f></focusin>
		<focusout public="1" set="method"><f a="?callb">
	<f a="">
		<t path="js.JqEvent"/>
		<e path="Void"/>
	</f>
	<c path="js.JQuery"/>
</f></focusout>
		<hover public="1" set="method"><f a="onOver:?onOut">
	<f a="">
		<t path="js.JqEvent"/>
		<e path="Void"/>
	</f>
	<f a=""><e path="Void"/></f>
	<c path="js.JQuery"/>
</f></hover>
		<keydown public="1" set="method"><f a="?callb">
	<f a="">
		<t path="js.JqEvent"/>
		<e path="Void"/>
	</f>
	<c path="js.JQuery"/>
</f></keydown>
		<keypress public="1" set="method"><f a="?callb">
	<f a="">
		<t path="js.JqEvent"/>
		<e path="Void"/>
	</f>
	<c path="js.JQuery"/>
</f></keypress>
		<keyup public="1" set="method"><f a="?callb">
	<f a="">
		<t path="js.JqEvent"/>
		<e path="Void"/>
	</f>
	<c path="js.JQuery"/>
</f></keyup>
		<mousedown public="1" set="method"><f a="?callb">
	<f a="">
		<t path="js.JqEvent"/>
		<e path="Void"/>
	</f>
	<c path="js.JQuery"/>
</f></mousedown>
		<mouseenter public="1" set="method"><f a="?callb">
	<f a="">
		<t path="js.JqEvent"/>
		<e path="Void"/>
	</f>
	<c path="js.JQuery"/>
</f></mouseenter>
		<mouseleave public="1" set="method"><f a="?callb">
	<f a="">
		<t path="js.JqEvent"/>
		<e path="Void"/>
	</f>
	<c path="js.JQuery"/>
</f></mouseleave>
		<mouseout public="1" set="method"><f a="?callb">
	<f a="">
		<t path="js.JqEvent"/>
		<e path="Void"/>
	</f>
	<c path="js.JQuery"/>
</f></mouseout>
		<mouseover public="1" set="method"><f a="?callb">
	<f a="">
		<t path="js.JqEvent"/>
		<e path="Void"/>
	</f>
	<c path="js.JQuery"/>
</f></mouseover>
		<mousemove public="1" set="method"><f a="?callb">
	<f a="">
		<t path="js.JqEvent"/>
		<e path="Void"/>
	</f>
	<c path="js.JQuery"/>
</f></mousemove>
		<mouseup public="1" set="method"><f a="?callb">
	<f a="">
		<t path="js.JqEvent"/>
		<e path="Void"/>
	</f>
	<c path="js.JQuery"/>
</f></mouseup>
		<load public="1" set="method"><f a="?callb">
	<f a="">
		<t path="js.JqEvent"/>
		<e path="Void"/>
	</f>
	<c path="js.JQuery"/>
</f></load>
		<ready public="1" set="method"><f a="callb">
	<f a="">
		<t path="js.JqEvent"/>
		<e path="Void"/>
	</f>
	<c path="js.JQuery"/>
</f></ready>
		<resize public="1" set="method"><f a="?callb">
	<f a="">
		<t path="js.JqEvent"/>
		<e path="Void"/>
	</f>
	<c path="js.JQuery"/>
</f></resize>
		<scroll public="1" set="method"><f a="?callb">
	<f a="">
		<t path="js.JqEvent"/>
		<e path="Void"/>
	</f>
	<c path="js.JQuery"/>
</f></scroll>
		<select public="1" set="method"><f a="?callb">
	<f a="">
		<t path="js.JqEvent"/>
		<e path="Void"/>
	</f>
	<c path="js.JQuery"/>
</f></select>
		<submit public="1" set="method"><f a="?callb">
	<f a="">
		<t path="js.JqEvent"/>
		<e path="Void"/>
	</f>
	<c path="js.JQuery"/>
</f></submit>
		<unload public="1" set="method"><f a="?callb">
	<f a="">
		<t path="js.JqEvent"/>
		<e path="Void"/>
	</f>
	<c path="js.JQuery"/>
</f></unload>
		<bind public="1" set="method"><f a="events:callb">
	<c path="String"/>
	<f a="">
		<t path="js.JqEvent"/>
		<e path="Void"/>
	</f>
	<c path="js.JQuery"/>
</f></bind>
		<delegate public="1" set="method"><f a="selector:events:callb">
	<c path="String"/>
	<c path="String"/>
	<f a="">
		<t path="js.JqEvent"/>
		<e path="Void"/>
	</f>
	<c path="js.JQuery"/>
</f></delegate>
		<die public="1" set="method"><f a="?events:?callb">
	<c path="String"/>
	<f a="">
		<t path="js.JqEvent"/>
		<e path="Void"/>
	</f>
	<c path="js.JQuery"/>
</f></die>
		<one public="1" set="method"><f a="events:callb">
	<c path="String"/>
	<f a="">
		<t path="js.JqEvent"/>
		<e path="Void"/>
	</f>
	<c path="js.JQuery"/>
</f></one>
		<live public="1" set="method"><f a="events:callb">
	<c path="String"/>
	<f a="">
		<t path="js.JqEvent"/>
		<e path="Void"/>
	</f>
	<c path="js.JQuery"/>
</f></live>
		<trigger public="1" set="method"><f a="events">
	<c path="String"/>
	<c path="js.JQuery"/>
</f></trigger>
		<triggerHandler public="1" set="method"><f a="events">
	<c path="String"/>
	<c path="js.JQuery"/>
</f></triggerHandler>
		<unbind public="1" set="method"><f a="?events:?callb">
	<c path="String"/>
	<f a="">
		<t path="js.JqEvent"/>
		<e path="Void"/>
	</f>
	<c path="js.JQuery"/>
</f></unbind>
		<undelegate public="1" set="method"><f a="?selector:?events:?callb">
	<c path="String"/>
	<c path="String"/>
	<f a="">
		<t path="js.JqEvent"/>
		<e path="Void"/>
	</f>
	<c path="js.JQuery"/>
</f></undelegate>
		<clearQueue public="1" set="method"><f a="?queueName">
	<c path="String"/>
	<c path="js.JQuery"/>
</f></clearQueue>
		<dequeue public="1" set="method"><f a="?queueName">
	<c path="String"/>
	<c path="js.JQuery"/>
</f></dequeue>
		<queue public="1" set="method"><f a="?queueName">
	<c path="String"/>
	<a><length><c path="Int"/></length></a>
</f></queue>
		<get public="1" set="method"><f a=""><c path="Array"><t path="js.HtmlDom"/></c></f></get>
		<is public="1" set="method"><f a="selector">
	<c path="String"/>
	<e path="Bool"/>
</f></is>
		<data public="1" params="T" set="method"><f a="key:?value">
	<c path="String"/>
	<c path="data.T"/>
	<c path="data.T"/>
</f></data>
		<removeData public="1" set="method"><f a="?key">
	<c path="String"/>
	<c path="js.JQuery"/>
</f></removeData>
		<serialize public="1" set="method"><f a=""><c path="String"/></f></serialize>
		<serializeArray public="1" set="method"><f a=""><c path="Array"><a>
	<value><c path="String"/></value>
	<name><c path="String"/></name>
</a></c></f></serializeArray>
		<iterator public="1" set="method"><f a=""><t path="Iterator"><c path="js.JQuery"/></t></f></iterator>
		<new public="1" set="method"><f a="html">
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="js.Lib" params="" file="/usr/share/haxe/std/js/Lib.hx">
		<isIE public="1" static="1"><e path="Bool"/></isIE>
		<isOpera public="1" static="1"><e path="Bool"/></isOpera>
		<document public="1" static="1"><t path="js.Document"/></document>
		<window public="1" static="1"><t path="js.Window"/></window>
		<onerror line="35" static="1"><f a=":">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
	<e path="Bool"/>
</f></onerror>
		<alert public="1" set="method" line="37" static="1"><f a="v">
	<d/>
	<e path="Void"/>
</f></alert>
		<eval public="1" get="inline" set="null" line="41" static="1"><f a="code">
	<c path="String"/>
	<d/>
</f></eval>
		<setErrorHandler public="1" get="inline" set="null" line="45" static="1"><f a="f">
	<f a=":">
		<c path="String"/>
		<c path="Array"><c path="String"/></c>
		<e path="Bool"/>
	</f>
	<e path="Void"/>
</f></setErrorHandler>
	</class>
	<class path="pushstate.History" params="" file="src/pushstate/History.hx" extern="1" interface="1">
		<length public="1" set="null"><c path="Int"/></length>
		<go public="1" set="method"><f a="?delta">
	<c path="Int"/>
	<e path="Void"/>
</f></go>
		<back public="1" set="method"><f a=""><e path="Void"/></f></back>
		<forward public="1" set="method"><f a=""><e path="Void"/></f></forward>
		<pushState public="1" set="method"><f a="data:title:?url">
	<d/>
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></pushState>
		<replaceState public="1" set="method"><f a="data:title:?url">
	<d/>
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></replaceState>
	</class>
	<class path="pushstate.Event" params="" file="src/pushstate/PopStateEvent.hx" module="pushstate.PopStateEvent" extern="1">
		<extends path="Object"/>
		<CAPTURING_PHASE public="1" get="inline" set="null" line="11" static="1"><c path="Int"/></CAPTURING_PHASE>
		<AT_TARGET public="1" get="inline" set="null" line="12" static="1"><c path="Int"/></AT_TARGET>
		<BUBBLING_PHASE public="1" get="inline" set="null" line="13" static="1"><c path="Int"/></BUBBLING_PHASE>
		<type public="1" set="null"><c path="String"/></type>
		<target public="1" set="null"><c path="pushstate.EventTarget"/></target>
		<currentTarget public="1" set="null"><c path="pushstate.EventTarget"/></currentTarget>
		<eventPhase public="1" set="null"><c path="Int"/></eventPhase>
		<bubbles public="1" set="null"><e path="Bool"/></bubbles>
		<cancelable public="1" set="null"><e path="Bool"/></cancelable>
		<timeStamp public="1" set="null"><c path="Int"/></timeStamp>
		<namespaceURI public="1" set="null"><c path="String"/></namespaceURI>
		<defaultPrevented public="1" set="null"><e path="Bool"/></defaultPrevented>
		<stopPropagation public="1" set="method"><f a=""><e path="Void"/></f></stopPropagation>
		<preventDefault public="1" set="method"><f a=""><e path="Void"/></f></preventDefault>
		<initEvent public="1" set="method"><f a="eventTypeArg:canBubbleArg:cancelableArg">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></initEvent>
		<stopImmediatePropagation public="1" set="method"><f a=""><e path="Void"/></f></stopImmediatePropagation>
		<initEventNS public="1" set="method"><f a="namespaceURIArg:eventTypeArg:canBubbleArg:cancelableArg">
	<c path="String"/>
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></initEventNS>
	</class>
	<class path="pushstate.PopStateEvent" params="" file="src/pushstate/PopStateEvent.hx" extern="1">
		<extends path="pushstate.Event"/>
		<state public="1" set="null"><d/></state>
		<initPopStateEvent public="1" set="method"><f a="typeArg:canBubbleArg:cancelableArg:stateArg">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<d/>
	<e path="Void"/>
</f></initPopStateEvent>
	</class>
	<class path="pushstate.EventTarget" params="" file="src/pushstate/PopStateEvent.hx" module="pushstate.PopStateEvent" extern="1">
		<extends path="Object"/>
		<addEventListener public="1" set="method"><f a="type:listener:useCapture">
	<c path="String"/>
	<t path="pushstate.EventListener"><d/></t>
	<e path="Bool"/>
	<e path="Void"/>
</f></addEventListener>
		<removeEventListener public="1" set="method"><f a="type:listener:useCapture">
	<c path="String"/>
	<t path="pushstate.EventListener"><d/></t>
	<e path="Bool"/>
	<e path="Void"/>
</f></removeEventListener>
		<dispatchEvent public="1" set="method"><f a="evt">
	<c path="pushstate.Event"/>
	<e path="Bool"/>
</f></dispatchEvent>
		<addEventListenerNS public="1" set="method"><f a="namespaceURI:type:listener:useCapture">
	<c path="String"/>
	<c path="String"/>
	<t path="pushstate.EventListener"><d/></t>
	<e path="Bool"/>
	<e path="Void"/>
</f></addEventListenerNS>
		<removeEventListenerNS public="1" set="method"><f a="namespaceURI:type:listener:useCapture">
	<c path="String"/>
	<c path="String"/>
	<t path="pushstate.EventListener"><d/></t>
	<e path="Bool"/>
	<e path="Void"/>
</f></removeEventListenerNS>
	</class>
	<typedef path="pushstate.EventListener" params="T" file="src/pushstate/PopStateEvent.hx" module="pushstate.PopStateEvent"><f a="">
	<c path="pushstate.EventListener.T"/>
	<e path="Void"/>
</f></typedef>
	<class path="pushstate.PushState" params="" file="src/pushstate/PushState.hx">
		<inst static="1"><c path="pushstate.PushState"/></inst>
		<history static="1"><c path="pushstate.History"/></history>
		<basePath static="1"><c path="String"/></basePath>
		<onStateChange public="1" static="1">
			<c path="hsl.haxe.DirectSignaler"><t path="pushstate.StateData"/></c>
			<haxe_doc>
	* onStateChange is fired when the URL of the page changes, so
	*  - When the page first loads
	*  - When a link is clicked with the rel='pushstate' attribute
	*  - Back or Forward is clicked in the browser
	*  - PushState.push() is called manually
	* Listen to this event to be able to change your pages content
	* as the URL is updated.
	</haxe_doc>
		</onStateChange>
		<init public="1" set="method" line="55" static="1">
			<f a="?basePath">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc> 
	* init()
	* This initialises the PushState API for the current page.
	* Basically it:
	*  - sets up the PushState object
	*  - gets links with rel="pushstate" to use the PushState API
	*  - launches an initial onStateChange event so you can load your first page
	*  - listens to "onpopstate" event, so we can detect browser "Back" clicks etc.
	* In general you should call this before using any other part of the API.
	</haxe_doc>
		</init>
		<handleOnPopState set="method" line="78" static="1"><f a="e">
	<d/>
	<e path="Void"/>
</f></handleOnPopState>
		<stripURL set="method" line="93" static="1"><f a="path">
	<c path="String"/>
	<c path="String"/>
</f></stripURL>
		<push public="1" set="method" line="109" static="1">
			<f a="url">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	* push()
	* Use this to manually change the URL of the page without reloading.
	* An onStateChange event is dispatched, which you can use to load 
	* the appropriate content.
	</haxe_doc>
		</push>
		<replace public="1" set="method" line="131" static="1">
			<f a="url">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	* replace()
	* This changes the URL of the page without creating a new History item.
	* So for instance
	*  - You are on the page "/kittents"
	*  - You use PushState.push("/puppies")
	*  - You are now on "/puppies", if you were to press back you 
	*    would be on "kittens"
	*  - You now use PushState.replace("/aliens")
	*  - The URL is not "/aliens", but if you were to press back
	*    it would go to "/kittens", because a new History item
	*    was not created.
	</haxe_doc>
		</replace>
		<new set="method" line="38"><f a=""><e path="Void"/></f></new>
		<haxe_doc>
* PushState
* This class is used to access, trigger and listen to the HTML5 History API.
* This allows you to trigger changes to the pages content using Javascript,
* and update the URL of the page so that browser features such as bookmarking,
* clicking "back" or "forward", and sharing links still work.
* 
* This library is accessed using static methods, and accesses only part
* of the History API for simplicity.  Full support may be added later.
* 
* This library does not fix any cross-browser issues or provide a #hash fallback
* for older browsers.  I've tried to keep it lightweight and simple.
</haxe_doc>
	</class>
	<typedef path="pushstate.StateData" params="" file="src/pushstate/PushState.hx" module="pushstate.PushState">
		<a><url><c path="String"/></url></a>
		<haxe_doc>
* StateData
* 
* Contains data about the current History state.  For now we'll just use "url",
* but in future may support "title" and "data" from the browser History API.
</haxe_doc>
	</typedef>
</haxe>